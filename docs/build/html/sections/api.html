<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Programming API &mdash; Comet Toolbox 2024 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=6fefd858"></script>
        <script src="../_static/doctools.js?v=9a2dae69"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Contributing" href="contribute.html" />
    <link rel="prev" title="Usage" href="usage.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Comet Toolbox
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">Usage</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Programming API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#comet-methods">comet.methods</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#comet.methods.Cap"><code class="docutils literal notranslate"><span class="pre">Cap</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.Cap.connectivity"><code class="docutils literal notranslate"><span class="pre">Cap.connectivity()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.Cap.name"><code class="docutils literal notranslate"><span class="pre">Cap.name</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#comet.methods.ConnectivityMethod"><code class="docutils literal notranslate"><span class="pre">ConnectivityMethod</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.ConnectivityMethod.time_series"><code class="docutils literal notranslate"><span class="pre">ConnectivityMethod.time_series</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.ConnectivityMethod.T"><code class="docutils literal notranslate"><span class="pre">ConnectivityMethod.T</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.ConnectivityMethod.P"><code class="docutils literal notranslate"><span class="pre">ConnectivityMethod.P</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.ConnectivityMethod.diagonal"><code class="docutils literal notranslate"><span class="pre">ConnectivityMethod.diagonal</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.ConnectivityMethod.standardize"><code class="docutils literal notranslate"><span class="pre">ConnectivityMethod.standardize</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.ConnectivityMethod.fisher_z"><code class="docutils literal notranslate"><span class="pre">ConnectivityMethod.fisher_z</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.ConnectivityMethod.tril"><code class="docutils literal notranslate"><span class="pre">ConnectivityMethod.tril</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.ConnectivityMethod.connectivity"><code class="docutils literal notranslate"><span class="pre">ConnectivityMethod.connectivity()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.ConnectivityMethod.postproc"><code class="docutils literal notranslate"><span class="pre">ConnectivityMethod.postproc()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#comet.methods.DCC"><code class="docutils literal notranslate"><span class="pre">DCC</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.DCC.connectivity"><code class="docutils literal notranslate"><span class="pre">DCC.connectivity()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.DCC.name"><code class="docutils literal notranslate"><span class="pre">DCC.name</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#comet.methods.Edge_centric_connectivity"><code class="docutils literal notranslate"><span class="pre">Edge_centric_connectivity</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.Edge_centric_connectivity.connectivity"><code class="docutils literal notranslate"><span class="pre">Edge_centric_connectivity.connectivity()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.Edge_centric_connectivity.name"><code class="docutils literal notranslate"><span class="pre">Edge_centric_connectivity.name</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#comet.methods.FlexibleLeastSquares"><code class="docutils literal notranslate"><span class="pre">FlexibleLeastSquares</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.FlexibleLeastSquares.connectivity"><code class="docutils literal notranslate"><span class="pre">FlexibleLeastSquares.connectivity()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.FlexibleLeastSquares.name"><code class="docutils literal notranslate"><span class="pre">FlexibleLeastSquares.name</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#comet.methods.Hmm_Cont"><code class="docutils literal notranslate"><span class="pre">Hmm_Cont</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.Hmm_Cont.connectivity"><code class="docutils literal notranslate"><span class="pre">Hmm_Cont.connectivity()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.Hmm_Cont.name"><code class="docutils literal notranslate"><span class="pre">Hmm_Cont.name</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#comet.methods.Hmm_Disc"><code class="docutils literal notranslate"><span class="pre">Hmm_Disc</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.Hmm_Disc.connectivity"><code class="docutils literal notranslate"><span class="pre">Hmm_Disc.connectivity()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.Hmm_Disc.name"><code class="docutils literal notranslate"><span class="pre">Hmm_Disc.name</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#comet.methods.Jackknife"><code class="docutils literal notranslate"><span class="pre">Jackknife</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.Jackknife.centers"><code class="docutils literal notranslate"><span class="pre">Jackknife.centers()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.Jackknife.connectivity"><code class="docutils literal notranslate"><span class="pre">Jackknife.connectivity()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.Jackknife.name"><code class="docutils literal notranslate"><span class="pre">Jackknife.name</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#comet.methods.LeiDA"><code class="docutils literal notranslate"><span class="pre">LeiDA</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.LeiDA.connectivity"><code class="docutils literal notranslate"><span class="pre">LeiDA.connectivity()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.LeiDA.name"><code class="docutils literal notranslate"><span class="pre">LeiDA.name</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#comet.methods.PhaseSynchrony"><code class="docutils literal notranslate"><span class="pre">PhaseSynchrony</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.PhaseSynchrony.connectivity"><code class="docutils literal notranslate"><span class="pre">PhaseSynchrony.connectivity()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.PhaseSynchrony.name"><code class="docutils literal notranslate"><span class="pre">PhaseSynchrony.name</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#comet.methods.SlidingWindow"><code class="docutils literal notranslate"><span class="pre">SlidingWindow</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.SlidingWindow.centers"><code class="docutils literal notranslate"><span class="pre">SlidingWindow.centers()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.SlidingWindow.connectivity"><code class="docutils literal notranslate"><span class="pre">SlidingWindow.connectivity()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.SlidingWindow.name"><code class="docutils literal notranslate"><span class="pre">SlidingWindow.name</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#comet.methods.Sliding_Window"><code class="docutils literal notranslate"><span class="pre">Sliding_Window</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.Sliding_Window.connectivity"><code class="docutils literal notranslate"><span class="pre">Sliding_Window.connectivity()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.Sliding_Window.name"><code class="docutils literal notranslate"><span class="pre">Sliding_Window.name</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#comet.methods.Sliding_Window_Clustr"><code class="docutils literal notranslate"><span class="pre">Sliding_Window_Clustr</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.Sliding_Window_Clustr.connectivity"><code class="docutils literal notranslate"><span class="pre">Sliding_Window_Clustr.connectivity()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.Sliding_Window_Clustr.name"><code class="docutils literal notranslate"><span class="pre">Sliding_Window_Clustr.name</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#comet.methods.SpatialDistance"><code class="docutils literal notranslate"><span class="pre">SpatialDistance</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.SpatialDistance.connectivity"><code class="docutils literal notranslate"><span class="pre">SpatialDistance.connectivity()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.SpatialDistance.name"><code class="docutils literal notranslate"><span class="pre">SpatialDistance.name</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#comet.methods.Static_Mutual_Info"><code class="docutils literal notranslate"><span class="pre">Static_Mutual_Info</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.Static_Mutual_Info.connectivity"><code class="docutils literal notranslate"><span class="pre">Static_Mutual_Info.connectivity()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.Static_Mutual_Info.name"><code class="docutils literal notranslate"><span class="pre">Static_Mutual_Info.name</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#comet.methods.Static_Partial"><code class="docutils literal notranslate"><span class="pre">Static_Partial</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.Static_Partial.connectivity"><code class="docutils literal notranslate"><span class="pre">Static_Partial.connectivity()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.Static_Partial.name"><code class="docutils literal notranslate"><span class="pre">Static_Partial.name</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#comet.methods.Static_Pearson"><code class="docutils literal notranslate"><span class="pre">Static_Pearson</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.Static_Pearson.connectivity"><code class="docutils literal notranslate"><span class="pre">Static_Pearson.connectivity()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.Static_Pearson.name"><code class="docutils literal notranslate"><span class="pre">Static_Pearson.name</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#comet.methods.TemporalDerivatives"><code class="docutils literal notranslate"><span class="pre">TemporalDerivatives</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.TemporalDerivatives.centers"><code class="docutils literal notranslate"><span class="pre">TemporalDerivatives.centers()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.TemporalDerivatives.connectivity"><code class="docutils literal notranslate"><span class="pre">TemporalDerivatives.connectivity()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.TemporalDerivatives.name"><code class="docutils literal notranslate"><span class="pre">TemporalDerivatives.name</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#comet.methods.Time_Freq"><code class="docutils literal notranslate"><span class="pre">Time_Freq</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.Time_Freq.connectivity"><code class="docutils literal notranslate"><span class="pre">Time_Freq.connectivity()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.Time_Freq.name"><code class="docutils literal notranslate"><span class="pre">Time_Freq.name</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#comet.methods.WaveletCoherence"><code class="docutils literal notranslate"><span class="pre">WaveletCoherence</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.WaveletCoherence.connectivity"><code class="docutils literal notranslate"><span class="pre">WaveletCoherence.connectivity()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.WaveletCoherence.name"><code class="docutils literal notranslate"><span class="pre">WaveletCoherence.name</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#comet.methods.Windowless"><code class="docutils literal notranslate"><span class="pre">Windowless</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.Windowless.connectivity"><code class="docutils literal notranslate"><span class="pre">Windowless.connectivity()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#comet.methods.Windowless.name"><code class="docutils literal notranslate"><span class="pre">Windowless.name</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#comet-graph">comet.graph</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#comet.graph.avg_clustering_onella"><code class="docutils literal notranslate"><span class="pre">avg_clustering_onella()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#comet.graph.avg_shortest_path"><code class="docutils literal notranslate"><span class="pre">avg_shortest_path()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#comet.graph.backbone_wu"><code class="docutils literal notranslate"><span class="pre">backbone_wu()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#comet.graph.betweenness"><code class="docutils literal notranslate"><span class="pre">betweenness()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#comet.graph.binarise"><code class="docutils literal notranslate"><span class="pre">binarise()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#comet.graph.clustering_coef"><code class="docutils literal notranslate"><span class="pre">clustering_coef()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#comet.graph.degrees_und"><code class="docutils literal notranslate"><span class="pre">degrees_und()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#comet.graph.density_und"><code class="docutils literal notranslate"><span class="pre">density_und()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#comet.graph.distance_bin"><code class="docutils literal notranslate"><span class="pre">distance_bin()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#comet.graph.distance_wei"><code class="docutils literal notranslate"><span class="pre">distance_wei()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#comet.graph.efficiency"><code class="docutils literal notranslate"><span class="pre">efficiency()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#comet.graph.eigenvector_centrality_und"><code class="docutils literal notranslate"><span class="pre">eigenvector_centrality_und()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#comet.graph.gateway_coef_sign"><code class="docutils literal notranslate"><span class="pre">gateway_coef_sign()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#comet.graph.handle_negative_weights"><code class="docutils literal notranslate"><span class="pre">handle_negative_weights()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#comet.graph.invert"><code class="docutils literal notranslate"><span class="pre">invert()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#comet.graph.logtransform"><code class="docutils literal notranslate"><span class="pre">logtransform()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#comet.graph.matching_ind_und"><code class="docutils literal notranslate"><span class="pre">matching_ind_und()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#comet.graph.normalise"><code class="docutils literal notranslate"><span class="pre">normalise()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#comet.graph.pagerank_centrality"><code class="docutils literal notranslate"><span class="pre">pagerank_centrality()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#comet.graph.participation_coef"><code class="docutils literal notranslate"><span class="pre">participation_coef()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#comet.graph.participation_coef_sign"><code class="docutils literal notranslate"><span class="pre">participation_coef_sign()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#comet.graph.postproc"><code class="docutils literal notranslate"><span class="pre">postproc()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#comet.graph.randomise"><code class="docutils literal notranslate"><span class="pre">randomise()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#comet.graph.regular_matrix"><code class="docutils literal notranslate"><span class="pre">regular_matrix()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#comet.graph.small_world_propensity"><code class="docutils literal notranslate"><span class="pre">small_world_propensity()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#comet.graph.small_world_sigma"><code class="docutils literal notranslate"><span class="pre">small_world_sigma()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#comet.graph.symmetrise"><code class="docutils literal notranslate"><span class="pre">symmetrise()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#comet.graph.threshold"><code class="docutils literal notranslate"><span class="pre">threshold()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#comet.graph.transitivity_und"><code class="docutils literal notranslate"><span class="pre">transitivity_und()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#comet-multiverse">comet.multiverse</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#comet.multiverse.Multiverse"><code class="docutils literal notranslate"><span class="pre">Multiverse</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#comet.multiverse.Multiverse.name"><code class="docutils literal notranslate"><span class="pre">Multiverse.name</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#comet.multiverse.Multiverse.create"><code class="docutils literal notranslate"><span class="pre">Multiverse.create()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#comet.multiverse.Multiverse.run"><code class="docutils literal notranslate"><span class="pre">Multiverse.run()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#comet.multiverse.Multiverse.specification_curve"><code class="docutils literal notranslate"><span class="pre">Multiverse.specification_curve()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#comet.multiverse.Multiverse.summary"><code class="docutils literal notranslate"><span class="pre">Multiverse.summary()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#comet.multiverse.Multiverse.visualize"><code class="docutils literal notranslate"><span class="pre">Multiverse.visualize()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#comet.multiverse.in_notebook"><code class="docutils literal notranslate"><span class="pre">in_notebook()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#comet-data">comet.data</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#comet.data.clean"><code class="docutils literal notranslate"><span class="pre">clean()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#comet.data.load_example"><code class="docutils literal notranslate"><span class="pre">load_example()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#comet.data.load_single_state"><code class="docutils literal notranslate"><span class="pre">load_single_state()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#comet.data.load_timeseries"><code class="docutils literal notranslate"><span class="pre">load_timeseries()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#comet.data.save_results"><code class="docutils literal notranslate"><span class="pre">save_results()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="contribute.html">Contributing</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Comet Toolbox</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Programming API</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/sections/api.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="programming-api">
<h1>Programming API<a class="headerlink" href="#programming-api" title="Link to this heading"></a></h1>
<section id="comet-methods">
<h2>comet.methods<a class="headerlink" href="#comet-methods" title="Link to this heading"></a></h2>
<div class="toctree-wrapper compound">
</div>
<dl class="py class" id="module-comet.methods">
<dt class="sig sig-object py" id="comet.methods.Cap">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">comet.methods.</span></span><span class="sig-name descname"><span class="pre">Cap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_series</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">TIME_SERIES</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subject</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_states</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_subj_clusters</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalization</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#Cap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.Cap" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseDFCMethod</span></code></p>
<p>Wrapper function for the co-activation patterns (CAP) method
from the pydfc library: <a class="reference external" href="https://github.com/neurodatascience/dFC/">https://github.com/neurodatascience/dFC/</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time_series</strong> (<em>time_series.TIME_SERIES</em>) – The input time series data.</p></li>
<li><p><strong>subject</strong> (<em>int</em><em>, </em><em>optional</em>) – Subject index for which to compute the CAP. Default is 0.</p></li>
<li><p><strong>n_states</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of states for CAP. Default is 5.</p></li>
<li><p><strong>n_subj_clusters</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of subject clusters. Default is 5.</p></li>
<li><p><strong>normalization</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to normalize the data. Default is True.</p></li>
<li><p><strong>**params</strong> (<em>dict</em><em>, </em><em>optional</em>) – Additional parameters for the CAP method.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="comet.methods.Cap.connectivity">
<span class="sig-name descname"><span class="pre">connectivity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#Cap.connectivity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.Cap.connectivity" title="Link to this definition"></a></dt>
<dd><p>Calculate the co-activation patterns dynamic functional connectivity.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Dynamic functional connectivity estimated by the CAP method.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="comet.methods.Cap.name">
<span class="sig-name descname"><span class="pre">name</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'STATE</span> <span class="pre">Co-activation</span> <span class="pre">patterns'</span></em><a class="headerlink" href="#comet.methods.Cap.name" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="comet.methods.ConnectivityMethod">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">comet.methods.</span></span><span class="sig-name descname"><span class="pre">ConnectivityMethod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_series</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diagonal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">standardize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fisher_z</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tril</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#ConnectivityMethod"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.ConnectivityMethod" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Base class for all dynamic functional connectivity methods.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="comet.methods.ConnectivityMethod.time_series">
<span class="sig-name descname"><span class="pre">time_series</span></span><a class="headerlink" href="#comet.methods.ConnectivityMethod.time_series" title="Link to this definition"></a></dt>
<dd><p>Time series data.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="comet.methods.ConnectivityMethod.T">
<span class="sig-name descname"><span class="pre">T</span></span><a class="headerlink" href="#comet.methods.ConnectivityMethod.T" title="Link to this definition"></a></dt>
<dd><p>Number of timepoints.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="comet.methods.ConnectivityMethod.P">
<span class="sig-name descname"><span class="pre">P</span></span><a class="headerlink" href="#comet.methods.ConnectivityMethod.P" title="Link to this definition"></a></dt>
<dd><p>Number of parcels.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="comet.methods.ConnectivityMethod.diagonal">
<span class="sig-name descname"><span class="pre">diagonal</span></span><a class="headerlink" href="#comet.methods.ConnectivityMethod.diagonal" title="Link to this definition"></a></dt>
<dd><p>Value to set on the diagonal of connectivity matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int or float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="comet.methods.ConnectivityMethod.standardize">
<span class="sig-name descname"><span class="pre">standardize</span></span><a class="headerlink" href="#comet.methods.ConnectivityMethod.standardize" title="Link to this definition"></a></dt>
<dd><p>Whether to z-standardize the connectivity matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="comet.methods.ConnectivityMethod.fisher_z">
<span class="sig-name descname"><span class="pre">fisher_z</span></span><a class="headerlink" href="#comet.methods.ConnectivityMethod.fisher_z" title="Link to this definition"></a></dt>
<dd><p>Whether to apply Fisher z-transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="comet.methods.ConnectivityMethod.tril">
<span class="sig-name descname"><span class="pre">tril</span></span><a class="headerlink" href="#comet.methods.ConnectivityMethod.tril" title="Link to this definition"></a></dt>
<dd><p>Whether to return only the lower triangle of the matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="comet.methods.ConnectivityMethod.connectivity">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">connectivity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#ConnectivityMethod.connectivity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.ConnectivityMethod.connectivity" title="Link to this definition"></a></dt>
<dd><p>Abstract method to compute the connectivity matrix.
This method should be implemented in each child class.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – If the method is not implemented in the child class.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="comet.methods.ConnectivityMethod.postproc">
<span class="sig-name descname"><span class="pre">postproc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R_mat</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#ConnectivityMethod.postproc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.ConnectivityMethod.postproc" title="Link to this definition"></a></dt>
<dd><p>Post-process the connectivity matrix with optional Fisher z-transformation,
z-standardization, diagonal setting, and lower triangle extraction.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>R_mat</strong> (<em>np.ndarray</em>) – The connectivity matrix to be post-processed.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The post-processed connectivity matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="comet.methods.DCC">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">comet.methods.</span></span><span class="sig-name descname"><span class="pre">DCC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_series</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_cores</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">16</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">standardizeData</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diagonal</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">standardize</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fisher_z</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tril</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#DCC"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.DCC" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#comet.methods.ConnectivityMethod" title="comet.methods.ConnectivityMethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConnectivityMethod</span></code></a></p>
<p>Dynamic Conditional Correlation (DCC) as described by Lindquist et al. (2014).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time_series</strong> (<em>np.ndarray</em>) – The input time series data.</p></li>
<li><p><strong>num_cores</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of CPU cores to use for parallel processing. Default is 16.</p></li>
<li><p><strong>standardizeData</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to standardize the time series data. Default is True.</p></li>
<li><p><strong>diagonal</strong> (<em>int</em><em>, </em><em>optional</em>) – Value to set on the diagonal of connectivity matrices. Default is 0.</p></li>
<li><p><strong>standardize</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to z-standardize the connectivity matrices. Default is False.</p></li>
<li><p><strong>fisher_z</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to apply Fisher z-transformation. Default is False.</p></li>
<li><p><strong>tril</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to return only the lower triangle of the matrices. Default is False.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">References</p>
<p>Lindquist, M. A., Xu, Y., Nebel, M. B., &amp; Caffo, B. S. (2014). Evaluating dynamic bivariate correlations
in resting-state fMRI: a comparison study and a new approach. NeuroImage, 101, 531-546.
<a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2014.06.052">https://doi.org/10.1016/j.neuroimage.2014.06.052</a></p>
<dl class="py method">
<dt class="sig sig-object py" id="comet.methods.DCC.connectivity">
<span class="sig-name descname"><span class="pre">connectivity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#DCC.connectivity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.DCC.connectivity" title="Link to this definition"></a></dt>
<dd><p>DCC algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>theta</strong> (<em>T-by-N matrix</em>) – fMRI time series data</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>R</strong> (<em>N*N*T np.ndarray</em>) – estimated dynamic conditional correlation tensor</p></li>
<li><p><em>tuple</em> –</p>
<ul>
<li><p>H : dynamic conditional covariance tensor</p></li>
<li><p>Theta : GARCH(1,1) parameters</p></li>
<li><p>X : DCC parameters</p></li>
</ul>
</li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="comet.methods.DCC.name">
<span class="sig-name descname"><span class="pre">name</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'CONT</span> <span class="pre">Dynamic</span> <span class="pre">Conditional</span> <span class="pre">Correlation'</span></em><a class="headerlink" href="#comet.methods.DCC.name" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="comet.methods.Edge_centric_connectivity">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">comet.methods.</span></span><span class="sig-name descname"><span class="pre">Edge_centric_connectivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_series</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">standardizeData</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vlim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">standardize</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#Edge_centric_connectivity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.Edge_centric_connectivity" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#comet.methods.ConnectivityMethod" title="comet.methods.ConnectivityMethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConnectivityMethod</span></code></a></p>
<p>Edge-centric connectivity method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time_series</strong> (<em>np.ndarray</em>) – The input time series data.</p></li>
<li><p><strong>standardizeData</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to standardize the time series data. Default is True.</p></li>
<li><p><strong>vlim</strong> (<em>float</em><em>, </em><em>optional</em>) – Limit for plotting in the GUI (not used in the method itself). Default is 3.</p></li>
<li><p><strong>standardize</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to z-standardize the connectivity matrices. Default is False.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">References</p>
<p>Faskowitz, J., Esfahlani, F. Z., Jo, Y., Sporns, O., &amp; Betzel, R. F. (2020). Edge-centric functional
network representations of human cerebral cortex reveal overlapping system-level architecture.
Nature neuroscience, 23(12), 1644–1654. DOI: <a class="reference external" href="https://doi.org/10.1038/s41593-020-00719-y">https://doi.org/10.1038/s41593-020-00719-y</a></p>
<dl class="py method">
<dt class="sig sig-object py" id="comet.methods.Edge_centric_connectivity.connectivity">
<span class="sig-name descname"><span class="pre">connectivity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#Edge_centric_connectivity.connectivity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.Edge_centric_connectivity.connectivity" title="Link to this definition"></a></dt>
<dd><p>Calculate edge-centric connectivity.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><em>np.ndarray</em> – Dynamic functional connectivity as a PxPxN array.</p></li>
<li><p><em>tuple</em> –</p>
<ul>
<li><p>np.ndarray : Edge time series.</p></li>
<li><p>np.ndarray : Indices of the upper triangle of the connectivity matrix.</p></li>
<li><p>np.ndarray : Indices of the upper triangle of the connectivity matrix.</p></li>
</ul>
</li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="comet.methods.Edge_centric_connectivity.name">
<span class="sig-name descname"><span class="pre">name</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'CONT</span> <span class="pre">Edge-centric</span> <span class="pre">Connectivity'</span></em><a class="headerlink" href="#comet.methods.Edge_centric_connectivity.name" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="comet.methods.FlexibleLeastSquares">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">comet.methods.</span></span><span class="sig-name descname"><span class="pre">FlexibleLeastSquares</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_series</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">standardizeData</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_cores</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">16</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diagonal</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">standardize</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fisher_z</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tril</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#FlexibleLeastSquares"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.FlexibleLeastSquares" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#comet.methods.ConnectivityMethod" title="comet.methods.ConnectivityMethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConnectivityMethod</span></code></a></p>
<p>Flexible Least Squares connectivity method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time_series</strong> (<em>np.ndarray</em>) – The input time series data.</p></li>
<li><p><strong>standardizeData</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to standardize the time series data. Default is True.</p></li>
<li><p><strong>mu</strong> (<em>float</em><em>, </em><em>optional</em>) – Regularization parameter for the flexible least squares algorithm. Default is 100.</p></li>
<li><p><strong>num_cores</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of CPU cores to use for parallel processing. Default is 16.</p></li>
<li><p><strong>diagonal</strong> (<em>int</em><em>, </em><em>optional</em>) – Value to set on the diagonal of connectivity matrices. Default is 0.</p></li>
<li><p><strong>standardize</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to z-standardize the connectivity matrices. Default is False.</p></li>
<li><p><strong>fisher_z</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to apply Fisher z-transformation. Default is False.</p></li>
<li><p><strong>tril</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to return only the lower triangle of the matrices. Default is False.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">References</p>
<p>Liao, W., Wu, G. R., Xu, Q., Ji, G. J., Zhang, Z., Zang, Y. F., &amp; Lu, G. (2014).
DynamicBC: a MATLAB toolbox for dynamic brain connectome analysis. Brain connectivity, 4(10), 780-790.
<a class="reference external" href="https://doi.org/10.1089/brain.2014.0253">https://doi.org/10.1089/brain.2014.0253</a></p>
<dl class="py method">
<dt class="sig sig-object py" id="comet.methods.FlexibleLeastSquares.connectivity">
<span class="sig-name descname"><span class="pre">connectivity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#FlexibleLeastSquares.connectivity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.FlexibleLeastSquares.connectivity" title="Link to this definition"></a></dt>
<dd><p>Calculate flexible least squares connectivity as implemented in the DynamicBC toolbox</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Dynamic functional connectivity as a PxPxN array.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="comet.methods.FlexibleLeastSquares.name">
<span class="sig-name descname"><span class="pre">name</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'CONT</span> <span class="pre">Flexible</span> <span class="pre">Least</span> <span class="pre">Squares'</span></em><a class="headerlink" href="#comet.methods.FlexibleLeastSquares.name" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="comet.methods.Hmm_Cont">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">comet.methods.</span></span><span class="sig-name descname"><span class="pre">Hmm_Cont</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_series</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">TIME_SERIES</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subject</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_states</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalization</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#Hmm_Cont"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.Hmm_Cont" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseDFCMethod</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="comet.methods.Hmm_Cont.connectivity">
<span class="sig-name descname"><span class="pre">connectivity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#Hmm_Cont.connectivity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.Hmm_Cont.connectivity" title="Link to this definition"></a></dt>
<dd><p>Calculate the continuous hidden Markov model dynamic functional connectivity.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Dynamic functional connectivity estimated by the HMM method.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="comet.methods.Hmm_Cont.name">
<span class="sig-name descname"><span class="pre">name</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'STATE</span> <span class="pre">Continuous</span> <span class="pre">Hidden</span> <span class="pre">Markov</span> <span class="pre">Model'</span></em><a class="headerlink" href="#comet.methods.Hmm_Cont.name" title="Link to this definition"></a></dt>
<dd><p>Wrapper function for the continuous hidden Markov model (HMM) method
from the pydfc library: <a class="reference external" href="https://github.com/neurodatascience/dFC/">https://github.com/neurodatascience/dFC/</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time_series</strong> (<em>time_series.TIME_SERIES</em>) – The input time series data.</p></li>
<li><p><strong>subject</strong> (<em>int</em><em>, </em><em>optional</em>) – Subject index for which to compute the HMM. Default is 0.</p></li>
<li><p><strong>n_states</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of states for the HMM. Default is 5.</p></li>
<li><p><strong>iterations</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of iterations for the HMM. Default is 20.</p></li>
<li><p><strong>normalization</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to normalize the data. Default is True.</p></li>
<li><p><strong>**params</strong> (<em>dict</em><em>, </em><em>optional</em>) – Additional parameters for the HMM method.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="comet.methods.Hmm_Disc">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">comet.methods.</span></span><span class="sig-name descname"><span class="pre">Hmm_Disc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_series</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">TIME_SERIES</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subject</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">windowsize</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">44</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_overlap</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clstr_base_measure</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'SlidingWindow'</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'SlidingWindow'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sw_method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'pear_corr'</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'pear_corr'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tapered_window</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dhmm_obs_state_ratio</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.6666666666666666</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_states</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_subj_clusters</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalization</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#Hmm_Disc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.Hmm_Disc" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseDFCMethod</span></code></p>
<p>Wrapper function for the discrete hidden Markov model (HMM) method
from the pydfc library: <a class="reference external" href="https://github.com/neurodatascience/dFC/">https://github.com/neurodatascience/dFC/</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time_series</strong> (<em>time_series.TIME_SERIES</em>) – The input time series data.</p></li>
<li><p><strong>subject</strong> (<em>int</em><em>, </em><em>optional</em>) – Subject index for which to compute the HMM. Default is 0.</p></li>
<li><p><strong>windowsize</strong> (<em>int</em><em>, </em><em>optional</em>) – Size of the sliding window. Default is 44.</p></li>
<li><p><strong>n_overlap</strong> (<em>float</em><em>, </em><em>optional</em>) – Overlap between windows. Default is 0.5.</p></li>
<li><p><strong>clstr_base_measure</strong> (<em>{'SlidingWindow'}</em><em>, </em><em>optional</em>) – Base measure for clustering. Default is ‘SlidingWindow’.</p></li>
<li><p><strong>sw_method</strong> (<em>{'pear_corr'}</em><em>, </em><em>optional</em>) – Sliding window method. Default is ‘pear_corr’.</p></li>
<li><p><strong>tapered_window</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to use a tapered window. Default is True.</p></li>
<li><p><strong>iterations</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of iterations for the HMM. Default is 20.</p></li>
<li><p><strong>dhmm_obs_state_ratio</strong> (<em>float</em><em>, </em><em>optional</em>) – Ratio of observed to hidden states. Default is 16/24.</p></li>
<li><p><strong>n_states</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of states for the HMM. Default is 5.</p></li>
<li><p><strong>n_subj_clusters</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of subject clusters. Default is 5.</p></li>
<li><p><strong>normalization</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to normalize the data. Default is True.</p></li>
<li><p><strong>**params</strong> (<em>dict</em><em>, </em><em>optional</em>) – Additional parameters for the HMM method.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="comet.methods.Hmm_Disc.connectivity">
<span class="sig-name descname"><span class="pre">connectivity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#Hmm_Disc.connectivity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.Hmm_Disc.connectivity" title="Link to this definition"></a></dt>
<dd><p>Calculate the discrete hidden Markov model dynamic functional connectivity.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Dynamic functional connectivity estimated by the HMM method.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="comet.methods.Hmm_Disc.name">
<span class="sig-name descname"><span class="pre">name</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'STATE</span> <span class="pre">Discrete</span> <span class="pre">Hidden</span> <span class="pre">Markov</span> <span class="pre">Model'</span></em><a class="headerlink" href="#comet.methods.Hmm_Disc.name" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="comet.methods.Jackknife">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">comet.methods.</span></span><span class="sig-name descname"><span class="pre">Jackknife</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_series</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">windowsize</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stepsize</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diagonal</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">standardize</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fisher_z</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tril</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#Jackknife"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.Jackknife" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#comet.methods.ConnectivityMethod" title="comet.methods.ConnectivityMethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConnectivityMethod</span></code></a></p>
<p>Jackknife correlation method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time_series</strong> (<em>np.ndarray</em>) – The input time series data.</p></li>
<li><p><strong>windowsize</strong> (<em>int</em><em>, </em><em>optional</em>) – Size of the sliding window. Default is 1.</p></li>
<li><p><strong>stepsize</strong> (<em>int</em><em>, </em><em>optional</em>) – Step size for sliding the window. Default is 1.</p></li>
<li><p><strong>diagonal</strong> (<em>int</em><em>, </em><em>optional</em>) – Value to set on the diagonal of connectivity matrices. Default is 0.</p></li>
<li><p><strong>standardize</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to z-standardize the connectivity matrices. Default is False.</p></li>
<li><p><strong>fisher_z</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to apply Fisher z-transformation. Default is False.</p></li>
<li><p><strong>tril</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to return only the lower triangle of the matrices. Default is False.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">References</p>
<p>Richter CG, Thompson WH, Bosman CA, Fries P. A jackknife approach to quantifying single-trial
correlation between covariance-based metrics undefined on a single-trial basis.
<a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2015.04.040">https://doi.org/10.1016/j.neuroimage.2015.04.040</a></p>
<dl class="py method">
<dt class="sig sig-object py" id="comet.methods.Jackknife.centers">
<span class="sig-name descname"><span class="pre">centers</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#Jackknife.centers"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.Jackknife.centers" title="Link to this definition"></a></dt>
<dd><p>Calculate the central index of each window so dynamic functional connectivity (dFC)
estimates can be related to the original time series.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Central index of each window.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="comet.methods.Jackknife.connectivity">
<span class="sig-name descname"><span class="pre">connectivity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#Jackknife.connectivity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.Jackknife.connectivity" title="Link to this definition"></a></dt>
<dd><p>Calculate jackknife correlation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Dynamic functional connectivity as a PxPxN array.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="comet.methods.Jackknife.name">
<span class="sig-name descname"><span class="pre">name</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'CONT</span> <span class="pre">Jackknife</span> <span class="pre">Correlation'</span></em><a class="headerlink" href="#comet.methods.Jackknife.name" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="comet.methods.LeiDA">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">comet.methods.</span></span><span class="sig-name descname"><span class="pre">LeiDA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_series</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flip_eigenvectors</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diagonal</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">standardize</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fisher_z</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tril</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#LeiDA"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.LeiDA" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#comet.methods.ConnectivityMethod" title="comet.methods.ConnectivityMethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConnectivityMethod</span></code></a></p>
<p>Leading Eigenvector Dynamics.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time_series</strong> (<em>np.ndarray</em>) – The input time series data.</p></li>
<li><p><strong>flip_eigenvectors</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to flip the eigenvectors so that the largest component is negative. Default is False.</p></li>
<li><p><strong>diagonal</strong> (<em>int</em><em>, </em><em>optional</em>) – Value to set on the diagonal of connectivity matrices. Default is 0.</p></li>
<li><p><strong>standardize</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to z-standardize the connectivity matrices. Default is False.</p></li>
<li><p><strong>fisher_z</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to apply Fisher z-transformation. Default is False.</p></li>
<li><p><strong>tril</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to return only the lower triangle of the matrices. Default is False.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">References</p>
<p>Cabral, J., Vidaurre, D., Marques, P., Magalhães, R., Silva Moreira, P., Miguel Soares, J., … &amp; Kringelbach, M. L. (2017).
Cognitive performance in healthy older adults relates to spontaneous switching between states of functional connectivity during rest.
Scientific reports, 7(1), 5135. <a class="reference external" href="https://doi.org/10.1038/s41598-017-05425-7">https://doi.org/10.1038/s41598-017-05425-7</a></p>
<p>Olsen, A. S., Lykkebo-Valløe, A., Ozenne, B., Madsen, M. K., Stenbæk, D. S., Armand, S., … &amp; Fisher, P. M. (2022). Psilocybin modulation
of time-varying functional connectivity is associated with plasma psilocin and subjective effects. Neuroimage, 264, 119716.
<a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2022.119716">https://doi.org/10.1016/j.neuroimage.2022.119716</a></p>
<p>Vohryzek, J., Deco, G., Cessac, B., Kringelbach, M. L., &amp; Cabral, J. (2020). Ghost attractors in spontaneous brain activity:
Recurrent excursions into functionally-relevant BOLD phase-locking states. Frontiers in systems neuroscience, 14, 20.
<a class="reference external" href="https://doi.org/10.3389/fnsys.2020.00020">https://doi.org/10.3389/fnsys.2020.00020</a></p>
<dl class="py method">
<dt class="sig sig-object py" id="comet.methods.LeiDA.connectivity">
<span class="sig-name descname"><span class="pre">connectivity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#LeiDA.connectivity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.LeiDA.connectivity" title="Link to this definition"></a></dt>
<dd><p>Calculate Leading Eigenvector Dynamics Analysis (LeiDA).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><em>np.ndarray</em> – Dynamic functional connectivity as a PxPxN array.</p></li>
<li><p><em>np.ndarray</em> – Leading eigenvectors.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="comet.methods.LeiDA.name">
<span class="sig-name descname"><span class="pre">name</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'CONT</span> <span class="pre">Leading</span> <span class="pre">Eigenvector</span> <span class="pre">Dynamics'</span></em><a class="headerlink" href="#comet.methods.LeiDA.name" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="comet.methods.PhaseSynchrony">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">comet.methods.</span></span><span class="sig-name descname"><span class="pre">PhaseSynchrony</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_series</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'crp'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'phcoh'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'teneto'</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'crp'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diagonal</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">standardize</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fisher_z</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tril</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#PhaseSynchrony"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.PhaseSynchrony" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#comet.methods.ConnectivityMethod" title="comet.methods.ConnectivityMethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConnectivityMethod</span></code></a></p>
<p>Instantaneous Phase Synchronization methods.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time_series</strong> (<em>np.ndarray</em>) – The input time series data.</p></li>
<li><p><strong>method</strong> (<em>{'crp'</em><em>, </em><em>'phcoh'</em><em>, </em><em>'teneto'}</em><em>, </em><em>optional</em>) – The phase synchrony method to use. Default is ‘crp’.</p></li>
<li><p><strong>diagonal</strong> (<em>int</em><em>, </em><em>optional</em>) – Value to set on the diagonal of connectivity matrices. Default is 0.</p></li>
<li><p><strong>standardize</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to z-standardize the connectivity matrices. Default is False.</p></li>
<li><p><strong>fisher_z</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to apply Fisher z-transformation. Default is False.</p></li>
<li><p><strong>tril</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to return only the lower triangle of the matrices. Default is False.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">References</p>
<p>Honari, H., Choe, A. S., &amp; Lindquist, M. A. (2021). Evaluating phase synchronization methods in fMRI:
A comparison study and new approaches. NeuroImage, 228, 117704. <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2020.117704">https://doi.org/10.1016/j.neuroimage.2020.117704</a></p>
<dl class="py method">
<dt class="sig sig-object py" id="comet.methods.PhaseSynchrony.connectivity">
<span class="sig-name descname"><span class="pre">connectivity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#PhaseSynchrony.connectivity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.PhaseSynchrony.connectivity" title="Link to this definition"></a></dt>
<dd><p>Calculate instantaneous phase synchrony.
CARE: Hilbert transform needs narrowband signal to produce meaningful results.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Dynamic functional connectivity as a PxPxN array.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="comet.methods.PhaseSynchrony.name">
<span class="sig-name descname"><span class="pre">name</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'CONT</span> <span class="pre">Phase</span> <span class="pre">Synchronization'</span></em><a class="headerlink" href="#comet.methods.PhaseSynchrony.name" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="comet.methods.SlidingWindow">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">comet.methods.</span></span><span class="sig-name descname"><span class="pre">SlidingWindow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_series</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">windowsize</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">29</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stepsize</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'rectangular'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'gaussian'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'hamming'</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'rectangular'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diagonal</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">standardize</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fisher_z</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tril</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#SlidingWindow"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.SlidingWindow" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#comet.methods.ConnectivityMethod" title="comet.methods.ConnectivityMethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConnectivityMethod</span></code></a></p>
<p>Sliding Window connectivity method.</p>
<p>This is the most widely used dynamic functional connectivity method. It involves sliding
a window over the data. Covariance is estimated for each windowed section.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time_series</strong> (<em>np.ndarray</em>) – The input time series data.</p></li>
<li><p><strong>windowsize</strong> (<em>int</em><em>, </em><em>optional</em>) – Size of the sliding window. Default is 29.</p></li>
<li><p><strong>stepsize</strong> (<em>int</em><em>, </em><em>optional</em>) – Step size for sliding the window. Default is 1.</p></li>
<li><p><strong>shape</strong> (<em>{'rectangular'</em><em>, </em><em>'gaussian'</em><em>, </em><em>'hamming'}</em><em>, </em><em>optional</em>) – Shape of the window. Default is ‘rectangular’.</p></li>
<li><p><strong>std</strong> (<em>float</em><em>, </em><em>optional</em>) – Standard deviation for the Gaussian window. Default is 10.</p></li>
<li><p><strong>diagonal</strong> (<em>int</em><em>, </em><em>optional</em>) – Value to set on the diagonal of connectivity matrices. Default is 0.</p></li>
<li><p><strong>standardize</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to z-standardize the connectivity matrices. Default is False.</p></li>
<li><p><strong>fisher_z</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to apply Fisher z-transformation. Default is False.</p></li>
<li><p><strong>tril</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to return only the lower triangle of the matrices. Default is False.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="comet.methods.SlidingWindow.centers">
<span class="sig-name descname"><span class="pre">centers</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#SlidingWindow.centers"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.SlidingWindow.centers" title="Link to this definition"></a></dt>
<dd><p>Calculate the central index of each window so dynamic functional connectivity (dFC)
estimates can be related to the original time series.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Central index of each window.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="comet.methods.SlidingWindow.connectivity">
<span class="sig-name descname"><span class="pre">connectivity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#SlidingWindow.connectivity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.SlidingWindow.connectivity" title="Link to this definition"></a></dt>
<dd><p>Calculate sliding window correlation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Dynamic functional connectivity as a PxPxN array.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="comet.methods.SlidingWindow.name">
<span class="sig-name descname"><span class="pre">name</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'CONT</span> <span class="pre">Sliding</span> <span class="pre">Window'</span></em><a class="headerlink" href="#comet.methods.SlidingWindow.name" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="comet.methods.Sliding_Window">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">comet.methods.</span></span><span class="sig-name descname"><span class="pre">Sliding_Window</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_series</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">TIME_SERIES</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clstr_distance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'euclidean'</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'euclidean'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#Sliding_Window"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.Sliding_Window" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseDFCMethod</span></code></p>
<p>Wrapper function for the sliding window connectivity method
from the pydfc library: <a class="reference external" href="https://github.com/neurodatascience/dFC/">https://github.com/neurodatascience/dFC/</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time_series</strong> (<em>time_series.TIME_SERIES</em>) – The input time series data.</p></li>
<li><p><strong>clstr_distance</strong> (<em>{'euclidean'}</em><em>, </em><em>optional</em>) – Distance metric for clustering. Default is ‘euclidean’.</p></li>
<li><p><strong>**params</strong> (<em>dict</em><em>, </em><em>optional</em>) – Additional parameters for the Sliding Window method.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="comet.methods.Sliding_Window.connectivity">
<span class="sig-name descname"><span class="pre">connectivity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#Sliding_Window.connectivity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.Sliding_Window.connectivity" title="Link to this definition"></a></dt>
<dd><p>Calculate the sliding window dynamic functional connectivity.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Dynamic functional connectivity estimated by the sliding window method.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="comet.methods.Sliding_Window.name">
<span class="sig-name descname"><span class="pre">name</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'CONT</span> <span class="pre">Sliding</span> <span class="pre">Window</span> <span class="pre">(pydfc)'</span></em><a class="headerlink" href="#comet.methods.Sliding_Window.name" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="comet.methods.Sliding_Window_Clustr">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">comet.methods.</span></span><span class="sig-name descname"><span class="pre">Sliding_Window_Clustr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_series</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">TIME_SERIES</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subject</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">windowsize</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">44</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_overlap</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tapered_window</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_states</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_subj_clusters</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalization</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clstr_distance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'euclidean'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'manhattan'</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'euclidean'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#Sliding_Window_Clustr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.Sliding_Window_Clustr" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseDFCMethod</span></code></p>
<p>Wrapper function for the sliding window clustering method
from the pydfc library: <a class="reference external" href="https://github.com/neurodatascience/dFC/">https://github.com/neurodatascience/dFC/</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time_series</strong> (<em>time_series.TIME_SERIES</em>) – The input time series data.</p></li>
<li><p><strong>subject</strong> (<em>int</em><em>, </em><em>optional</em>) – Subject index for which to compute the sliding window clustering. Default is 0.</p></li>
<li><p><strong>windowsize</strong> (<em>int</em><em>, </em><em>optional</em>) – Size of the sliding window. Default is 44.</p></li>
<li><p><strong>n_overlap</strong> (<em>float</em><em>, </em><em>optional</em>) – Overlap between windows. Default is 0.5.</p></li>
<li><p><strong>tapered_window</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to use a tapered window. Default is True.</p></li>
<li><p><strong>n_states</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of states for clustering. Default is 5.</p></li>
<li><p><strong>n_subj_clusters</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of subject clusters. Default is 5.</p></li>
<li><p><strong>normalization</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to normalize the data. Default is True.</p></li>
<li><p><strong>clstr_distance</strong> (<em>{'euclidean'</em><em>, </em><em>'manhattan'}</em><em>, </em><em>optional</em>) – Distance metric for clustering. Default is ‘euclidean’.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="comet.methods.Sliding_Window_Clustr.connectivity">
<span class="sig-name descname"><span class="pre">connectivity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#Sliding_Window_Clustr.connectivity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.Sliding_Window_Clustr.connectivity" title="Link to this definition"></a></dt>
<dd><p>Calculate the sliding window clustering dynamic functional connectivity.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Dynamic functional connectivity estimated by the sliding window clustering method.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="comet.methods.Sliding_Window_Clustr.name">
<span class="sig-name descname"><span class="pre">name</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'STATE</span> <span class="pre">Sliding</span> <span class="pre">Window</span> <span class="pre">Clustering'</span></em><a class="headerlink" href="#comet.methods.Sliding_Window_Clustr.name" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="comet.methods.SpatialDistance">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">comet.methods.</span></span><span class="sig-name descname"><span class="pre">SpatialDistance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_series</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dist</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'euclidean'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'cosine'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'cityblock'</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'euclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diagonal</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">standardize</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fisher_z</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tril</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#SpatialDistance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.SpatialDistance" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#comet.methods.ConnectivityMethod" title="comet.methods.ConnectivityMethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConnectivityMethod</span></code></a></p>
<p>Spatial Distance connectivity method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time_series</strong> (<em>np.ndarray</em>) – The input time series data.</p></li>
<li><p><strong>dist</strong> (<em>{'euclidean'</em><em>, </em><em>'cosine'</em><em>, </em><em>'cityblock'}</em><em>, </em><em>optional</em>) – Type of distance metric to use. Default is ‘euclidean’.</p></li>
<li><p><strong>diagonal</strong> (<em>int</em><em>, </em><em>optional</em>) – Value to set on the diagonal of connectivity matrices. Default is 0.</p></li>
<li><p><strong>standardize</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to z-standardize the connectivity matrices. Default is False.</p></li>
<li><p><strong>fisher_z</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to apply Fisher z-transformation. Default is False.</p></li>
<li><p><strong>tril</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to return only the lower triangle of the matrices. Default is False.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">References</p>
<p>William Hedley Thompson, Per Brantefors, Peter Fransson. From static
to temporal network theory: Applications to functional brain connectivity.
<a class="reference external" href="https://doi.org/10.1162/NETN_a_00011">https://doi.org/10.1162/NETN_a_00011</a></p>
<dl class="py method">
<dt class="sig sig-object py" id="comet.methods.SpatialDistance.connectivity">
<span class="sig-name descname"><span class="pre">connectivity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#SpatialDistance.connectivity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.SpatialDistance.connectivity" title="Link to this definition"></a></dt>
<dd><p>Calculate spatial distance correlation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Dynamic functional connectivity as a PxPxN array.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="comet.methods.SpatialDistance.name">
<span class="sig-name descname"><span class="pre">name</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'CONT</span> <span class="pre">Spatial</span> <span class="pre">Distance'</span></em><a class="headerlink" href="#comet.methods.SpatialDistance.name" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="comet.methods.Static_Mutual_Info">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">comet.methods.</span></span><span class="sig-name descname"><span class="pre">Static_Mutual_Info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_series</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_bins</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diagonal</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">standardize</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fisher_z</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tril</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#Static_Mutual_Info"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.Static_Mutual_Info" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#comet.methods.ConnectivityMethod" title="comet.methods.ConnectivityMethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConnectivityMethod</span></code></a></p>
<p>Static functional connectivity method using mutual information.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time_series</strong> (<em>np.ndarray</em>) – The input time series data.</p></li>
<li><p><strong>num_bins</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of bins to use for the mutual information calculation. Default is 10.</p></li>
<li><p><strong>diagonal</strong> (<em>int</em><em>, </em><em>optional</em>) – Value to set on the diagonal of connectivity matrices. Default is 0.</p></li>
<li><p><strong>standardize</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to z-standardize the connectivity matrices. Default is False.</p></li>
<li><p><strong>fisher_z</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to apply Fisher z-transformation. Default is False.</p></li>
<li><p><strong>tril</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to return only the lower triangle of the matrices. Default is False.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="comet.methods.Static_Mutual_Info.connectivity">
<span class="sig-name descname"><span class="pre">connectivity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#Static_Mutual_Info.connectivity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.Static_Mutual_Info.connectivity" title="Link to this definition"></a></dt>
<dd><p>Calculate the functional connectivity.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Static functional connectivity matrix.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="comet.methods.Static_Mutual_Info.name">
<span class="sig-name descname"><span class="pre">name</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'STATIC</span> <span class="pre">Mutual</span> <span class="pre">Information'</span></em><a class="headerlink" href="#comet.methods.Static_Mutual_Info.name" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="comet.methods.Static_Partial">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">comet.methods.</span></span><span class="sig-name descname"><span class="pre">Static_Partial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_series</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diagonal</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">standardize</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fisher_z</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tril</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#Static_Partial"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.Static_Partial" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#comet.methods.ConnectivityMethod" title="comet.methods.ConnectivityMethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConnectivityMethod</span></code></a></p>
<p>Static functional connectivity method using partial correlation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time_series</strong> (<em>np.ndarray</em>) – The input time series data.</p></li>
<li><p><strong>diagonal</strong> (<em>int</em><em>, </em><em>optional</em>) – Value to set on the diagonal of connectivity matrices. Default is 0.</p></li>
<li><p><strong>standardize</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to z-standardize the connectivity matrices. Default is False.</p></li>
<li><p><strong>fisher_z</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to apply Fisher z-transformation. Default is False.</p></li>
<li><p><strong>tril</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to return only the lower triangle of the matrices. Default is False.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="comet.methods.Static_Partial.connectivity">
<span class="sig-name descname"><span class="pre">connectivity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#Static_Partial.connectivity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.Static_Partial.connectivity" title="Link to this definition"></a></dt>
<dd><p>Calculate the functional connectivity.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Static functional connectivity matrix.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="comet.methods.Static_Partial.name">
<span class="sig-name descname"><span class="pre">name</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'STATIC</span> <span class="pre">Partial</span> <span class="pre">Correlation'</span></em><a class="headerlink" href="#comet.methods.Static_Partial.name" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="comet.methods.Static_Pearson">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">comet.methods.</span></span><span class="sig-name descname"><span class="pre">Static_Pearson</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_series</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diagonal</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">standardize</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fisher_z</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tril</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#Static_Pearson"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.Static_Pearson" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#comet.methods.ConnectivityMethod" title="comet.methods.ConnectivityMethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConnectivityMethod</span></code></a></p>
<p>Static functional connectivity method using Pearson correlation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time_series</strong> (<em>np.ndarray</em>) – The input time series data.</p></li>
<li><p><strong>diagonal</strong> (<em>int</em><em>, </em><em>optional</em>) – Value to set on the diagonal of connectivity matrices. Default is 0.</p></li>
<li><p><strong>standardize</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to z-standardize the connectivity matrices. Default is False.</p></li>
<li><p><strong>fisher_z</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to apply Fisher z-transformation. Default is False.</p></li>
<li><p><strong>tril</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to return only the lower triangle of the matrices. Default is False.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="comet.methods.Static_Pearson.connectivity">
<span class="sig-name descname"><span class="pre">connectivity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#Static_Pearson.connectivity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.Static_Pearson.connectivity" title="Link to this definition"></a></dt>
<dd><p>Calculate the functional connectivity.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Static functional connectivity matrix.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="comet.methods.Static_Pearson.name">
<span class="sig-name descname"><span class="pre">name</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'STATIC</span> <span class="pre">Pearson</span> <span class="pre">Correlation'</span></em><a class="headerlink" href="#comet.methods.Static_Pearson.name" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="comet.methods.TemporalDerivatives">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">comet.methods.</span></span><span class="sig-name descname"><span class="pre">TemporalDerivatives</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_series</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">windowsize</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">7</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diagonal</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">standardize</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fisher_z</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tril</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#TemporalDerivatives"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.TemporalDerivatives" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#comet.methods.ConnectivityMethod" title="comet.methods.ConnectivityMethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConnectivityMethod</span></code></a></p>
<p>Multiplication of Temporal Derivatives connectivity method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time_series</strong> (<em>np.ndarray</em>) – The input time series data.</p></li>
<li><p><strong>windowsize</strong> (<em>int</em><em>, </em><em>optional</em>) – Size of the sliding window. Default is 7.</p></li>
<li><p><strong>diagonal</strong> (<em>int</em><em>, </em><em>optional</em>) – Value to set on the diagonal of connectivity matrices. Default is 0.</p></li>
<li><p><strong>standardize</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to z-standardize the connectivity matrices. Default is False.</p></li>
<li><p><strong>fisher_z</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to apply Fisher z-transformation. Default is False.</p></li>
<li><p><strong>tril</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to return only the lower triangle of the matrices. Default is False.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">References</p>
<p>Shine JM, Koyejo O, Bell PT, Gorgolewski KJ, Gilat M, Poldrack RA. Estimation of
dynamic functional connectivity using Multiplication of Temporal Derivatives.
<a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2015.07.064">https://doi.org/10.1016/j.neuroimage.2015.07.064</a>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="comet.methods.TemporalDerivatives.centers">
<span class="sig-name descname"><span class="pre">centers</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#TemporalDerivatives.centers"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.TemporalDerivatives.centers" title="Link to this definition"></a></dt>
<dd><p>Calculate the central index of each window so dynamic functional connectivity (dFC)
estimates can be related to the original time series.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Central index of each window.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="comet.methods.TemporalDerivatives.connectivity">
<span class="sig-name descname"><span class="pre">connectivity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#TemporalDerivatives.connectivity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.TemporalDerivatives.connectivity" title="Link to this definition"></a></dt>
<dd><p>Calculate multiplication of temporal derivatives.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Dynamic functional connectivity as a PxPxN array.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="comet.methods.TemporalDerivatives.name">
<span class="sig-name descname"><span class="pre">name</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'CONT</span> <span class="pre">Multiplication</span> <span class="pre">of</span> <span class="pre">Temporal</span> <span class="pre">Derivatives'</span></em><a class="headerlink" href="#comet.methods.TemporalDerivatives.name" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="comet.methods.Time_Freq">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">comet.methods.</span></span><span class="sig-name descname"><span class="pre">Time_Freq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_series</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">TIME_SERIES</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_cores</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coi_correction</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#Time_Freq"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.Time_Freq" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseDFCMethod</span></code></p>
<p>Wrapper function for the time-frequency connectivity method
from the pydfc library: <a class="reference external" href="https://github.com/neurodatascience/dFC/">https://github.com/neurodatascience/dFC/</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time_series</strong> (<em>time_series.TIME_SERIES</em>) – The input time series data.</p></li>
<li><p><strong>num_cores</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of CPU cores to use for parallel processing. Default is 8.</p></li>
<li><p><strong>coi_correction</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to apply cone of influence correction. Default is True.</p></li>
<li><p><strong>**params</strong> (<em>dict</em><em>, </em><em>optional</em>) – Additional parameters for the Time-Frequency method.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="comet.methods.Time_Freq.connectivity">
<span class="sig-name descname"><span class="pre">connectivity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#Time_Freq.connectivity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.Time_Freq.connectivity" title="Link to this definition"></a></dt>
<dd><p>Calculate the time-frequency dynamic functional connectivity.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Dynamic functional connectivity estimated by the time-frequency method.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="comet.methods.Time_Freq.name">
<span class="sig-name descname"><span class="pre">name</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'CONT</span> <span class="pre">Time-frequency</span> <span class="pre">(pydfc)'</span></em><a class="headerlink" href="#comet.methods.Time_Freq.name" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="comet.methods.WaveletCoherence">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">comet.methods.</span></span><span class="sig-name descname"><span class="pre">WaveletCoherence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_series</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'weighted'</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'weighted'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">TR</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.72</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmin</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.007</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmax</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_scales</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">drop_scales</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">drop_timepoints</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diagonal</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">standardize</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fisher_z</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tril</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#WaveletCoherence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.WaveletCoherence" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#comet.methods.ConnectivityMethod" title="comet.methods.ConnectivityMethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConnectivityMethod</span></code></a></p>
<p>Instantaneous Wavelet Coherence.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time_series</strong> (<em>np.ndarray</em>) – The input time series data.</p></li>
<li><p><strong>method</strong> (<em>{'weighted'}</em><em>, </em><em>optional</em>) – The method to use for calculating wavelet coherence. Default is ‘weighted’.</p></li>
<li><p><strong>TR</strong> (<em>float</em><em>, </em><em>optional</em>) – Repetition time of the data. Default is 0.72.</p></li>
<li><p><strong>fmin</strong> (<em>float</em><em>, </em><em>optional</em>) – Minimum frequency for wavelet transform. Default is 0.007.</p></li>
<li><p><strong>fmax</strong> (<em>float</em><em>, </em><em>optional</em>) – Maximum frequency for wavelet transform. Default is 0.15.</p></li>
<li><p><strong>n_scales</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of scales for wavelet transform. Default is 15.</p></li>
<li><p><strong>drop_scales</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of scales to drop from the edges. Default is 2.</p></li>
<li><p><strong>drop_timepoints</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of time points to drop from the edges. Default is 50.</p></li>
<li><p><strong>diagonal</strong> (<em>int</em><em>, </em><em>optional</em>) – Value to set on the diagonal of connectivity matrices. Default is 0.</p></li>
<li><p><strong>standardize</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to z-standardize the connectivity matrices. Default is False.</p></li>
<li><p><strong>fisher_z</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to apply Fisher z-transformation. Default is False.</p></li>
<li><p><strong>tril</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to return only the lower triangle of the matrices. Default is False.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">References</p>
<p>Jacob Billings, Manish Saggar, Jaroslav Hlinka, Shella Keilholz, Giovanni Petri; Simplicial and
topological descriptions of human brain dynamics. Network Neuroscience 2021; 5 (2): 549–568.
<a class="reference external" href="https://doi.org/10.1162/netn_a_00190">https://doi.org/10.1162/netn_a_00190</a></p>
<dl class="py method">
<dt class="sig sig-object py" id="comet.methods.WaveletCoherence.connectivity">
<span class="sig-name descname"><span class="pre">connectivity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#WaveletCoherence.connectivity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.WaveletCoherence.connectivity" title="Link to this definition"></a></dt>
<dd><p>Calculate instantaneous wavelet coherence.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Dynamic functional connectivity as a PxPxN array.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="comet.methods.WaveletCoherence.name">
<span class="sig-name descname"><span class="pre">name</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'CONT</span> <span class="pre">Wavelet</span> <span class="pre">Coherence'</span></em><a class="headerlink" href="#comet.methods.WaveletCoherence.name" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="comet.methods.Windowless">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">comet.methods.</span></span><span class="sig-name descname"><span class="pre">Windowless</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_series</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">TIME_SERIES</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subject</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_states</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_subj_clusters</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalization</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#Windowless"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.Windowless" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseDFCMethod</span></code></p>
<p>Wrapper function for the windowless method
from the pydfc library: <a class="reference external" href="https://github.com/neurodatascience/dFC/">https://github.com/neurodatascience/dFC/</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time_series</strong> (<em>time_series.TIME_SERIES</em>) – The input time series data.</p></li>
<li><p><strong>subject</strong> (<em>int</em><em>, </em><em>optional</em>) – Subject index for which to compute the windowless method. Default is 0.</p></li>
<li><p><strong>n_states</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of states for the method. Default is 5.</p></li>
<li><p><strong>n_subj_clusters</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of subject clusters. Default is 5.</p></li>
<li><p><strong>normalization</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to normalize the data. Default is True.</p></li>
<li><p><strong>**params</strong> (<em>dict</em><em>, </em><em>optional</em>) – Additional parameters for the windowless method.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="comet.methods.Windowless.connectivity">
<span class="sig-name descname"><span class="pre">connectivity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/methods.html#Windowless.connectivity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.methods.Windowless.connectivity" title="Link to this definition"></a></dt>
<dd><p>Calculate the windowless dynamic functional connectivity.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Dynamic functional connectivity estimated by the windowless method.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="comet.methods.Windowless.name">
<span class="sig-name descname"><span class="pre">name</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'STATE</span> <span class="pre">Windowless'</span></em><a class="headerlink" href="#comet.methods.Windowless.name" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="comet-graph">
<h2>comet.graph<a class="headerlink" href="#comet-graph" title="Link to this heading"></a></h2>
<div class="toctree-wrapper compound">
</div>
<dl class="py function" id="module-comet.graph">
<dt class="sig sig-object py" id="comet.graph.avg_clustering_onella">
<span class="sig-prename descclassname"><span class="pre">comet.graph.</span></span><span class="sig-name descname"><span class="pre">avg_clustering_onella</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">W</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="../_modules/comet/graph.html#avg_clustering_onella"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.graph.avg_clustering_onella" title="Link to this definition"></a></dt>
<dd><p>Average clustering coefficient as described by Onnela et al. (2005) and as implemented in
<a class="reference external" href="https://kk1995.github.io/BauerLab/BauerLab/MATLAB/lib/+mouse/+graph/smallWorldPropensity.html">https://kk1995.github.io/BauerLab/BauerLab/MATLAB/lib/+mouse/+graph/smallWorldPropensity.html</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>W</strong> (<em>NxN np.ndarray</em>) – binary or weighted, undirected connection matrix</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>C</strong> – average clustering coefficient</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">References</p>
<p>Onnela, J. P., Saramäki, J., Kertész, J., &amp; Kaski, K. (2005). Intensity and
coherence of motifs in weighted complex networks. Physical Review E, 71(6), 065103.
DOI: <a class="reference external" href="https://doi.org/10.1103/PhysRevE.71.065103">https://doi.org/10.1103/PhysRevE.71.065103</a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="comet.graph.avg_shortest_path">
<span class="sig-prename descclassname"><span class="pre">comet.graph.</span></span><span class="sig-name descname"><span class="pre">avg_shortest_path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_diagonal</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_infinite</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="reference internal" href="../_modules/comet/graph.html#avg_shortest_path"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.graph.avg_shortest_path" title="Link to this definition"></a></dt>
<dd><p>Average shortest path length calculated from a connectivity matrix.</p>
<p>If the matrix is weighted, the inverse of the weights is used as a proxy of distance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>G</strong> (<em>NxN np.ndarray</em>) – undirected connection matrix (binary or weighted)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>D</strong> – average shortest path length</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="comet.graph.backbone_wu">
<span class="sig-prename descclassname"><span class="pre">comet.graph.</span></span><span class="sig-name descname"><span class="pre">backbone_wu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">CIJ</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">avgdeg</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/comet/graph.html#backbone_wu"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.graph.backbone_wu" title="Link to this definition"></a></dt>
<dd><p>This is a wrapper function for the backbone_wu() function
of the bctpy toolbox: <a class="reference external" href="https://github.com/aestrivex/bctpy">https://github.com/aestrivex/bctpy</a>.</p>
<p>The network backbone contains the dominant connections in the network
and may be used to aid network visualization. This function computes
the backbone of a given weighted and undirected connection matrix CIJ,
using a minimum-spanning-tree based algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>CIJ</strong> (<em>NxN np.ndarray</em>) – weighted undirected connection matrix</p></li>
<li><p><strong>avgdeg</strong> (<em>float</em>) – desired average degree of backbone</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – print out edges whilst building spanning tree. Default False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>CIJtree</strong> (<em>NxN np.ndarray</em>) – connection matrix of the minimum spanning tree of CIJ</p></li>
<li><p><strong>CIJclus</strong> (<em>NxN np.ndarray</em>) – connection matrix of the minimum spanning tree plus strongest
connections up to some average degree ‘avgdeg’. Identical to CIJtree
if the degree requirement is already met.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Nodes with zero strength are discarded.</p>
<dl class="simple">
<dt>CIJclus will have a total average degree exactly equal to</dt><dd><p>(or very close to) ‘avgdeg’.</p>
</dd>
</dl>
<p>‘avgdeg’ backfill is handled slightly differently than in Hagmann et al. (2008)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="comet.graph.betweenness">
<span class="sig-prename descclassname"><span class="pre">comet.graph.</span></span><span class="sig-name descname"><span class="pre">betweenness</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="../_modules/comet/graph.html#betweenness"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.graph.betweenness" title="Link to this definition"></a></dt>
<dd><p>This is a wrapper function for the betweenness_*() functions
of the bctpy toolbox: <a class="reference external" href="https://github.com/aestrivex/bctpy">https://github.com/aestrivex/bctpy</a>.</p>
<p>Node betweenness centrality is the fraction of all shortest paths in
the network that contain a given node. Nodes with high values of
betweenness centrality participate in a large number of shortest paths.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>G</strong> (<em>NxN np.ndarray</em>) – binary/weighted directed/undirected connection matrix</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>BC</strong> – node betweenness centrality vector</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Nx1 np.ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Binary:
Betweenness centrality may be normalised to the range [0,1] as
BC/[(N-1)(N-2)], where N is the number of nodes in the network.</p>
<p>Weighted:
The input matrix must be a connection-length matrix, typically
obtained via a mapping from weight to length. For instance, in a
weighted correlation network higher correlations are more naturally
interpreted as shorter distances and the input matrix should
consequently be some inverse of the connectivity matrix.
Betweenness centrality may be normalised to the range [0,1] as
BC/[(N-1)(N-2)], where N is the number of nodes in the network.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="comet.graph.binarise">
<span class="sig-prename descclassname"><span class="pre">comet.graph.</span></span><span class="sig-name descname"><span class="pre">binarise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">W</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="../_modules/comet/graph.html#binarise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.graph.binarise" title="Link to this definition"></a></dt>
<dd><p>Binarise connectivity/adjacency matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>W</strong> (<em>PxP np.ndarray</em>) – adjacency/connectivity matrix</p></li>
<li><p><strong>copy</strong> (<em>bool</em><em>, </em><em>optional</em>) – if True, a copy of W is returned, otherwise W is modified in place
default is True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>W</strong> – binarised adjacency/connectivity matrix</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>PxP np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="comet.graph.clustering_coef">
<span class="sig-prename descclassname"><span class="pre">comet.graph.</span></span><span class="sig-name descname"><span class="pre">clustering_coef</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">W</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="../_modules/comet/graph.html#clustering_coef"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.graph.clustering_coef" title="Link to this definition"></a></dt>
<dd><p>This is a wrapper function for the clustering_coef_*() functions
of the bctpy toolbox: <a class="reference external" href="https://github.com/aestrivex/bctpy">https://github.com/aestrivex/bctpy</a>.</p>
<p>The binary clustering coefficient is the fraction of triangles around a node
(equiv. the fraction of nodes neighbors that are neighbors of each other).</p>
<p>The weighted clustering coefficient is the average “intensity” of triangles
around a node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>W</strong> (<em>NxN np.ndarray</em>) – weighted undirected connection matrix</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>C</strong> – clustering coefficient vector</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Nx1 np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="comet.graph.degrees_und">
<span class="sig-prename descclassname"><span class="pre">comet.graph.</span></span><span class="sig-name descname"><span class="pre">degrees_und</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">CIJ</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="../_modules/comet/graph.html#degrees_und"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.graph.degrees_und" title="Link to this definition"></a></dt>
<dd><p>This is a wrapper function for the degrees_und() function
of the bctpy toolbox: <a class="reference external" href="https://github.com/aestrivex/bctpy">https://github.com/aestrivex/bctpy</a>.</p>
<p>Node degree is the number of links connected to the node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>CIJ</strong> (<em>NxN np.ndarray</em>) – undirected binary/weighted connection matrix</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>deg</strong> – node degree</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Nx1 np.ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Weight information is discarded.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="comet.graph.density_und">
<span class="sig-prename descclassname"><span class="pre">comet.graph.</span></span><span class="sig-name descname"><span class="pre">density_und</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">CIJ</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/comet/graph.html#density_und"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.graph.density_und" title="Link to this definition"></a></dt>
<dd><p>This is a wrapper function for the density_und() function
of the bctpy toolbox: <a class="reference external" href="https://github.com/aestrivex/bctpy">https://github.com/aestrivex/bctpy</a>.</p>
<p>Density is the fraction of present connections to possible connections.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>CIJ</strong> (<em>NxN np.ndarray</em>) – directed weighted/binary connection matrix</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>kden</strong> (<em>float</em>) – density</p></li>
<li><p><strong>N</strong> (<em>int</em>) – number of vertices</p></li>
<li><p><strong>k</strong> (<em>int</em>) – number of edges</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Assumes CIJ is directed and has no self-connections.
Weight information is discarded.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="comet.graph.distance_bin">
<span class="sig-prename descclassname"><span class="pre">comet.graph.</span></span><span class="sig-name descname"><span class="pre">distance_bin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="../_modules/comet/graph.html#distance_bin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.graph.distance_bin" title="Link to this definition"></a></dt>
<dd><p>Distance matrix calculation for binary networks with significantly
improved performance due to numba compilation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>G</strong> (<em>PxP np.ndarray</em>) – undireted weighted adjacency/connectivity matrix</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>D</strong> – (inverse) distance matrix</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>PxP np.ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Algorithm: Matrix multiplication to find paths, faster than original Dijkstra’s algorithm</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="comet.graph.distance_wei">
<span class="sig-prename descclassname"><span class="pre">comet.graph.</span></span><span class="sig-name descname"><span class="pre">distance_wei</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inv</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="../_modules/comet/graph.html#distance_wei"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.graph.distance_wei" title="Link to this definition"></a></dt>
<dd><p>(Inverse) distance matrix for weighted networks with significantly
improved performance due to numba compilation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>PxP np.ndarray</em>) – undireted weighted adjacency/connectivity matrix</p></li>
<li><p><strong>inv</strong> (<em>bool</em><em>, </em><em>optional</em>) – if True, the element wise inverse of the distance matrux is returned. Default is True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>D</strong> – (inverse) distance matrix</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>PxP np.ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Algorithm: Modified Dijkstra’s algorithm</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="comet.graph.efficiency">
<span class="sig-prename descclassname"><span class="pre">comet.graph.</span></span><span class="sig-name descname"><span class="pre">efficiency</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="../_modules/comet/graph.html#efficiency"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.graph.efficiency" title="Link to this definition"></a></dt>
<dd><p>Efficiency for binary and weighted networks (global and local)</p>
<p>Optimized version of the bctpy implelementation by Roan LaPlante (<a class="reference external" href="https://github.com/aestrivex/bctpy">https://github.com/aestrivex/bctpy</a>)</p>
<p>Global efficiency is the average of inverse shortest path length, and is inversely related to the characteristic path length.
Local efficiency is the global efficiency computed on the neighborhood of the node, and is related to the clustering coefficient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Gw</strong> (<em>PxP np.ndarray</em>) – undireted adjacency/connectivity matrix (binary or weighted)</p></li>
<li><p><strong>local</strong> (<em>bool</em><em>, </em><em>optional</em>) – if True, local efficiency is computed. Default is False (global efficiency)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>E (global)</strong> (<em>float</em>) – global efficiency, if local is False</p></li>
<li><p><strong>E (local)</strong> (<em>Nx1 np.ndarray</em>) – local efficiency, if local is True</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">References</p>
<p>Latora, V., &amp; Marchiori, M. (2001). Efficient behavior of small-world networks.
Physical review letters, 87(19), 198701. DOI: <a class="reference external" href="https://doi.org/10.1103/PhysRevLett.87.198701">https://doi.org/10.1103/PhysRevLett.87.198701</a></p>
<p>Onnela, J. P., Saramäki, J., Kertész, J., &amp; Kaski, K. (2004). Intensity and coherence of motifs in weighted c
omplex networks. Physical Review E, 71(6), 065103. DOI: <a class="reference external" href="https://doi.org/10.1103/PhysRevE.71.065103">https://doi.org/10.1103/PhysRevE.71.065103</a></p>
<p>Fagiolo, G. (2007). Clustering in complex directed networks. Physical Review E, 76(2), 026107.
DOI: <a class="reference external" href="https://doi.org/10.1103/PhysRevE.76.026107">https://doi.org/10.1103/PhysRevE.76.026107</a></p>
<p>Rubinov, M., &amp; Sporns, O. (2010). Complex network measures of brain connectivity: uses and interpretations.
Neuroimage, 52(3), 1059-1069. DOI: <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2009.10.003">https://doi.org/10.1016/j.neuroimage.2009.10.003</a></p>
<p>Wang, Y., Ghumare, E., Vandenberghe, R., &amp; Dupont, P. (2017). Comparison of different generalizations of clustering coefficient
and local efficiency for weighted undirected graphs. Neural computation, 29(2), 313-331. DOI: <a class="reference external" href="https://doi.org/10.1162/NECO_a_00914">https://doi.org/10.1162/NECO_a_00914</a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="comet.graph.eigenvector_centrality_und">
<span class="sig-prename descclassname"><span class="pre">comet.graph.</span></span><span class="sig-name descname"><span class="pre">eigenvector_centrality_und</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">CIJ</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="../_modules/comet/graph.html#eigenvector_centrality_und"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.graph.eigenvector_centrality_und" title="Link to this definition"></a></dt>
<dd><p>This is a wrapper function for the eigenvector_centrality_*() functions
of the bctpy toolbox: <a class="reference external" href="https://github.com/aestrivex/bctpy">https://github.com/aestrivex/bctpy</a>.</p>
<p>Eigenector centrality is a self-referential measure of centrality:
nodes have high eigenvector centrality if they connect to other nodes
that have high eigenvector centrality. The eigenvector centrality of
node i is equivalent to the ith element in the eigenvector
corresponding to the largest eigenvalue of the adjacency matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>CIJ</strong> (<em>NxN np.ndarray</em>) – Binary/weighted undirected adjacency matrix</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>v</strong> – Eigenvector associated with the largest eigenvalue of the matrix</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Nx1 np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="comet.graph.gateway_coef_sign">
<span class="sig-prename descclassname"><span class="pre">comet.graph.</span></span><span class="sig-name descname"><span class="pre">gateway_coef_sign</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">W</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ci</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'louvain'</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'louvain'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centrality_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'degree'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'betweenness'</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'degree'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/comet/graph.html#gateway_coef_sign"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.graph.gateway_coef_sign" title="Link to this definition"></a></dt>
<dd><p>This is a wrapper function for the gateway_coef_sign() function
of the bctpy toolbox: <a class="reference external" href="https://github.com/aestrivex/bctpy">https://github.com/aestrivex/bctpy</a>.</p>
<p>The gateway coefficient is a variant of participation coefficient.
It is weighted by how critical the connections are to intermodular
connectivity (e.g. if a node is the only connection between its
module and another module, it will have a higher gateway coefficient,
unlike participation coefficient).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>W</strong> (<em>NxN np.ndarray</em>) – undirected signed connection matrix</p></li>
<li><p><strong>ci</strong> (<em>Nx1 np.ndarray</em>) – community affiliation vector</p></li>
<li><p><strong>centrality_type</strong> (<em>enum</em>) – ‘degree’ - uses the weighted degree (i.e, node strength)
‘betweenness’ - uses the betweenness centrality</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>Gpos</strong> (<em>N x nr_mod np.ndarray</em>) – gateway coefficient for positive weights</p></li>
<li><p><strong>Gneg</strong> (<em>N x nr_mod np.ndarray</em>) – gateway coefficient for negative weights</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">References</p>
<p>Vargas ER, Wahl LM, Eur Phys J B (2014) 87:1-10</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="comet.graph.handle_negative_weights">
<span class="sig-prename descclassname"><span class="pre">comet.graph.</span></span><span class="sig-name descname"><span class="pre">handle_negative_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">W</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'absolute'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'discard'</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'absolute'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="../_modules/comet/graph.html#handle_negative_weights"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.graph.handle_negative_weights" title="Link to this definition"></a></dt>
<dd><p>Handle negative weights in a connectivity/adjacency matrix</p>
<p>Connectivity methods can produce negative estimates, which can be handled in different ways before graph analysis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>W</strong> (<em>PxP np.ndarray</em>) – adjacency/connectivity matrix</p></li>
<li><p><strong>type</strong> (<em>string</em><em>, </em><em>optional</em>) – type of handling, can be <em>absolute</em> or <em>discard</em>
default is <em>absolute</em></p></li>
<li><p><strong>copy</strong> (<em>bool</em><em>, </em><em>optional</em>) – if True, a copy of W is returned, otherwise W is modified in place
default is True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>W</strong> – adjacency/connectivity matrix with only positive weights</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>PxP np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="comet.graph.invert">
<span class="sig-prename descclassname"><span class="pre">comet.graph.</span></span><span class="sig-name descname"><span class="pre">invert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">W</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="../_modules/comet/graph.html#invert"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.graph.invert" title="Link to this definition"></a></dt>
<dd><p>Invert connectivity/adjacency matrix</p>
<p>Element wise inversion W such that each value W[i,j] will be 1 / W[i,j] (internode strengths internode distances)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>W</strong> (<em>PxP np.ndarray</em>) – adjacency/connectivity matrix</p></li>
<li><p><strong>copy</strong> (<em>bool</em><em>, </em><em>optional</em>) – if True, a copy of W is returned, otherwise W is modified in place
default is True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>W</strong> – element wise inverted adjacency/connectivity matrix</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>PxP np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="comet.graph.logtransform">
<span class="sig-prename descclassname"><span class="pre">comet.graph.</span></span><span class="sig-name descname"><span class="pre">logtransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">W</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="../_modules/comet/graph.html#logtransform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.graph.logtransform" title="Link to this definition"></a></dt>
<dd><p>Log transform of connectivity/adjacency matrix</p>
<p>Element wise log transform of W such that each value W[i,j] will be -log(W[i,j]</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>W</strong> (<em>PxP np.ndarray</em>) – adjacency/connectivity matrix</p></li>
<li><p><strong>epsilon</strong> (<em>float</em><em>, </em><em>optional</em>) – clipping value for numeric stability,
default is 1e-10</p></li>
<li><p><strong>copy</strong> (<em>bool</em><em>, </em><em>optional</em>) – if True, a copy of W is returned, otherwise W is modified in place
default is True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>W</strong> – element wise log transformed adjacency/connectivity matrix</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>PxP np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="comet.graph.matching_ind_und">
<span class="sig-prename descclassname"><span class="pre">comet.graph.</span></span><span class="sig-name descname"><span class="pre">matching_ind_und</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="../_modules/comet/graph.html#matching_ind_und"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.graph.matching_ind_und" title="Link to this definition"></a></dt>
<dd><p>Matching index for undirected networks</p>
<p>Based on the MATLAB implementation by Stuart Oldham:
<a class="reference external" href="https://github.com/StuartJO/FasterMatchingIndex">https://github.com/StuartJO/FasterMatchingIndex</a></p>
<p>Matching index is a measure of similarity between two nodes’ connectivity profiles
(excluding their mutual connection, should it exist).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>W</strong> (<em>PxP np.ndarray</em>) – undireted adjacency/connectivity matrix</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>M</strong> – matching index matrix</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>PxP np.ndarray</p>
</dd>
</dl>
<p class="rubric">References</p>
<p>Oldham, S., Fulcher, B. D., Aquino, K., Arnatkevičiūtė, A., Paquola, C.,
Shishegar, R., &amp; Fornito, A. (2022). Modeling spatial, developmental,
physiological, and topological constraints on human brain connectivity.
Science advances, 8(22), eabm6127. DOI: <a class="reference external" href="https://doi.org/10.1126/sciadv.abm6127">https://doi.org/10.1126/sciadv.abm6127</a></p>
<p>Betzel, R. F., Avena-Koenigsberger, A., Goñi, J., He, Y., De Reus, M. A.,
Griffa, A., … &amp; Sporns, O. (2016).
Generative models of the human connectome. Neuroimage, 124, 1054-1064.
DOI: <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2015.09.041">https://doi.org/10.1016/j.neuroimage.2015.09.041</a></p>
<p class="rubric">Notes</p>
<p>Important note: As of Jan 2024 there is a bug in the bctpy version of this function
(ncon2 = c1 * CIJ should instead be ncon2 = CIJ * use)</p>
<p>This bug is fixed/irrelevant here due to the more efficient implementation using
matrix operations</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="comet.graph.normalise">
<span class="sig-prename descclassname"><span class="pre">comet.graph.</span></span><span class="sig-name descname"><span class="pre">normalise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">W</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="../_modules/comet/graph.html#normalise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.graph.normalise" title="Link to this definition"></a></dt>
<dd><p>Normalise connectivity/adjacency matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>W</strong> (<em>PxP np.ndarray</em>) – adjacency/connectivity matrix</p></li>
<li><p><strong>copy</strong> (<em>bool</em><em>, </em><em>optional</em>) – if True, a copy of W is returned, otherwise W is modified in place
default is True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>W</strong> – normalised adjacency/connectivity matrix</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>PxP np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="comet.graph.pagerank_centrality">
<span class="sig-prename descclassname"><span class="pre">comet.graph.</span></span><span class="sig-name descname"><span class="pre">pagerank_centrality</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.85</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">falff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="../_modules/comet/graph.html#pagerank_centrality"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.graph.pagerank_centrality" title="Link to this definition"></a></dt>
<dd><p>This is a wrapper function for the pagerank_centrality() function
of the bctpy toolbox: <a class="reference external" href="https://github.com/aestrivex/bctpy">https://github.com/aestrivex/bctpy</a>.</p>
<p>The PageRank centrality is a variant of eigenvector centrality. This
function computes the PageRank centrality of each vertex in a graph.</p>
<p>Formally, PageRank is defined as the stationary distribution achieved
by instantiating a Markov chain on a graph. The PageRank centrality of
a given vertex, then, is proportional to the number of steps (or amount
of time) spent at that vertex as a result of such a process.</p>
<p>The PageRank index gets modified by the addition of a damping factor,
d. In terms of a Markov chain, the damping factor specifies the
fraction of the time that a random walker will transition to one of its
current state’s neighbors. The remaining fraction of the time the
walker is restarted at a random vertex. A common value for the damping
factor is d = 0.85.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>NxN np.narray</em>) – adjacency matrix</p></li>
<li><p><strong>d</strong> (<em>float</em>) – damping factor (see description)</p></li>
<li><p><strong>falff</strong> (<em>Nx1 np.ndarray</em><em> | </em><em>None</em>) – Initial page rank probability, non-negative values. Default value is
None. If not specified, a naive bayesian prior is used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>r</strong> – vectors of page rankings</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Nx1 np.ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Note: The algorithm will work well for smaller matrices (number of
nodes around 1000 or less)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="comet.graph.participation_coef">
<span class="sig-prename descclassname"><span class="pre">comet.graph.</span></span><span class="sig-name descname"><span class="pre">participation_coef</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">W</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ci</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'louvain'</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'louvain'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degree</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'undirected'</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'undirected'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="../_modules/comet/graph.html#participation_coef"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.graph.participation_coef" title="Link to this definition"></a></dt>
<dd><p>This is a wrapper function for the participation_coef functions
of the bctpy toolbox: <a class="reference external" href="https://github.com/aestrivex/bctpy">https://github.com/aestrivex/bctpy</a>.</p>
<p>The participation coefficient is a measure of diversity of intermodular
connections of individual nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>W</strong> (<em>NxN np.ndarray</em><em> or </em><em>scipy.sparse.csr_matrix</em>) – binary/weighted directed/undirected connection matrix</p></li>
<li><p><strong>ci</strong> (<em>Nx1 np.ndarray</em>) – community affiliation vector (just for the GUI, will always use bct.community_louvain())</p></li>
<li><p><strong>degree</strong> (<em>str</em>) – <dl class="simple">
<dt>Flag to describe nature of graph ‘undirected’: For undirected graphs</dt><dd><p>’in’: Uses the in-degree
‘out’: Uses the out-degree</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>P</strong> – participation coefficient</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Nx1 np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="comet.graph.participation_coef_sign">
<span class="sig-prename descclassname"><span class="pre">comet.graph.</span></span><span class="sig-name descname"><span class="pre">participation_coef_sign</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">W</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ci</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'louvain'</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'louvain'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/comet/graph.html#participation_coef_sign"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.graph.participation_coef_sign" title="Link to this definition"></a></dt>
<dd><p>This is a wrapper function for the participation_coef_sign() function
of the bctpy toolbox: <a class="reference external" href="https://github.com/aestrivex/bctpy">https://github.com/aestrivex/bctpy</a>.</p>
<p>The participation coefficient is a measure of diversity of intermodular
connections of individual nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>W</strong> (<em>NxN np.ndarray</em>) – undirected connection matrix with positive and negative weights</p></li>
<li><p><strong>ci</strong> (<em>Nx1 np.ndarray</em>) – community affiliation vector (just for the GUI, will always use bct.community_louvain())</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>Ppos</strong> (<em>Nx1 np.ndarray</em>) – participation coefficient from positive weights</p></li>
<li><p><strong>Pneg</strong> (<em>Nx1 np.ndarray</em>) – participation coefficient from negative weights</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="comet.graph.postproc">
<span class="sig-prename descclassname"><span class="pre">comet.graph.</span></span><span class="sig-name descname"><span class="pre">postproc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">W</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diag</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="../_modules/comet/graph.html#postproc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.graph.postproc" title="Link to this definition"></a></dt>
<dd><p>Postprocessing of connectivity/adjacency matrix</p>
<p>Ensures W is symmetric, sets diagonal to diag, removes NaNs and infinities, and ensures exact binarity</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>W</strong> (<em>PxP np.ndarray</em>) – adjacency/connectivity matrix</p></li>
<li><p><strong>diag</strong> (<em>int</em><em>, </em><em>optional</em>) – set diagonal to this value
default is 0</p></li>
<li><p><strong>copy</strong> (<em>bool</em><em>, </em><em>optional</em>) – if True, a copy of W is returned, otherwise W is modified in place
default is True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>W</strong> – processed adjacency/connectivity matrix</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>PxP np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="comet.graph.randomise">
<span class="sig-prename descclassname"><span class="pre">comet.graph.</span></span><span class="sig-name descname"><span class="pre">randomise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="../_modules/comet/graph.html#randomise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.graph.randomise" title="Link to this definition"></a></dt>
<dd><p>Randomly rewire edges of an adjacency/connectivity matrix</p>
<p>Implemented as in <a class="reference external" href="https://github.com/rkdan/small_world_propensity">https://github.com/rkdan/small_world_propensity</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>G</strong> (<em>PxP np.ndarray</em>) – adjacency/connectivity matrix</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>G_rand</strong> – randomised adjacency/connectivity matrix</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>PxP np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="comet.graph.regular_matrix">
<span class="sig-prename descclassname"><span class="pre">comet.graph.</span></span><span class="sig-name descname"><span class="pre">regular_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="../_modules/comet/graph.html#regular_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.graph.regular_matrix" title="Link to this definition"></a></dt>
<dd><p>Create a regular matrix</p>
<p>Adapted from <a class="reference external" href="https://github.com/rkdan/small_world_propensity">https://github.com/rkdan/small_world_propensity</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>PxP np.ndarray</em>) – adjacency/connectivity matrix</p></li>
<li><p><strong>r</strong> (<em>int</em>) – average effective radius of the network</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>M</strong> – adjacency matric of the regularised matrix</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>PxP np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="comet.graph.small_world_propensity">
<span class="sig-prename descclassname"><span class="pre">comet.graph.</span></span><span class="sig-name descname"><span class="pre">small_world_propensity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="../_modules/comet/graph.html#small_world_propensity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.graph.small_world_propensity" title="Link to this definition"></a></dt>
<dd><p>Small world propensity calculation for undirected and symmetric networks.
Clustering is calculated using the approach of Onnela et al. (2005).</p>
<p>Based on the MATLAB and Python implementations by Eric Bridgeford, Sarah F. Muldoon, and Ryan Daniels:
<a class="reference external" href="https://kk1995.github.io/BauerLab/BauerLab/MATLAB/lib/+mouse/+graph/smallWorldPropensity.html">https://kk1995.github.io/BauerLab/BauerLab/MATLAB/lib/+mouse/+graph/smallWorldPropensity.html</a>
<a class="reference external" href="https://github.com/rkdan/small_world_propensity">https://github.com/rkdan/small_world_propensity</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>F</strong> (<em>PxP np.ndarray</em>) – undirected and symmetric adjacency/connectivity matrix</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>SWP</strong> (<em>float</em>) – small world propensity of the matrix</p></li>
<li><p><strong>delta_C</strong> (<em>float</em>) – fractional deviation from the expected culstering coefficient of a random network</p></li>
<li><p><strong>delta_L</strong> (<em>float</em>) – fractional deviation from the expected path length of a random network</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – angle between delta_C and delta_L</p></li>
<li><p><strong>delta</strong> (<em>float</em>) – scaled version of alpha in the range of [-1,1]</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">References</p>
<p>Muldoon, S., Bridgeford, E. &amp; Bassett, D. Small-World Propensity and Weighted Brain Networks.
Sci Rep 6, 22057 (2016). DOI: <a class="reference external" href="https://doi.org/10.1038/srep22057">https://doi.org/10.1038/srep22057</a></p>
<p>Onnela, J. P., Saramäki, J., Kertész, J., &amp; Kaski, K. (2005). Intensity and
coherence of motifs in weighted complex networks. Physical Review E, 71(6), 065103.
DOI: <a class="reference external" href="https://doi.org/10.1103/PhysRevE.71.065103">https://doi.org/10.1103/PhysRevE.71.065103</a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="comet.graph.small_world_sigma">
<span class="sig-prename descclassname"><span class="pre">comet.graph.</span></span><span class="sig-name descname"><span class="pre">small_world_sigma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nrand</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="../_modules/comet/graph.html#small_world_sigma"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.graph.small_world_sigma" title="Link to this definition"></a></dt>
<dd><p>Small-worldness sigma for undirected networks (binary or weighted)</p>
<p>Small worldness sigma is calculated as the ratio of the clustering coefficient and the characteristic path length
of the real network to the average clustering coefficient and characteristic path length of the random networks.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>PxP np.ndarray</em>) – undireted adjacency/connectivity matrix</p></li>
<li><p><strong>nrand</strong> (<em>int</em><em>, </em><em>optional</em>) – number of random networks to generate (and average over). Default is 10.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>sigms</strong> – small-worldness sigma</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This implementation of small worldness relies on matrix operations and is <em>drastically</em> faster than the
Networkx implementation. However, it uses a different approch for rewiring edges, so the results will differ.</p>
<p>It automatically detects if the input matrix is binary or weighted.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="comet.graph.symmetrise">
<span class="sig-prename descclassname"><span class="pre">comet.graph.</span></span><span class="sig-name descname"><span class="pre">symmetrise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">W</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="../_modules/comet/graph.html#symmetrise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.graph.symmetrise" title="Link to this definition"></a></dt>
<dd><p>Symmetrise connectivity/adjacency matrix</p>
<p>Symmetrise W such that each value W[i,j] will be W[j,i].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>W</strong> (<em>PxP np.ndarray</em>) – adjacency/connectivity matrix</p></li>
<li><p><strong>copy</strong> (<em>bool</em><em>, </em><em>optional</em>) – if True, a copy of W is returned, otherwise W is modified in place
default is True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>W</strong> – symmetrised adjacency/connectivity matrix</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>PxP np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="comet.graph.threshold">
<span class="sig-prename descclassname"><span class="pre">comet.graph.</span></span><span class="sig-name descname"><span class="pre">threshold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">W</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'density'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'absolute'</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'density'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">density</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="../_modules/comet/graph.html#threshold"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.graph.threshold" title="Link to this definition"></a></dt>
<dd><p>Thresholding of connectivity/adjacency matrix</p>
<p>Performs absolute or density-based thresholding</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>W</strong> (<em>PxP np.ndarray</em>) – adjacency/connectivity matrix</p></li>
<li><p><strong>type</strong> (<em>string</em><em>, </em><em>optional</em>) – type of thresholding, can be <em>absolute</em> or <em>density</em>
default is <em>absolute</em></p></li>
<li><p><strong>threshold</strong> (<em>float</em><em>, </em><em>optional</em>) – threshold value for absolute thresholding
default is None</p></li>
<li><p><strong>density</strong> (<em>float</em><em>, </em><em>optional</em>) – density value for density-based thresholding, has to be between 0 and 1 (keep x% of strongest connections)
default is None</p></li>
<li><p><strong>copy</strong> (<em>bool</em><em>, </em><em>optional</em>) – if True, a copy of W is returned, otherwise W is modified in place
default is True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>W</strong> – thresholded adjacency/connectivity matrix</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>PxP np.ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The implemented for density based thresholding always keeps the exact same number of connections. If multiple edges have the same weight,
the included edges are chosen “randomly” (based on their order in the sorted indices). This is identical to the behaviour in the BCT implementation.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="comet.graph.transitivity_und">
<span class="sig-prename descclassname"><span class="pre">comet.graph.</span></span><span class="sig-name descname"><span class="pre">transitivity_und</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="../_modules/comet/graph.html#transitivity_und"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.graph.transitivity_und" title="Link to this definition"></a></dt>
<dd><p>Transitivity for undirected networks (binary and weighted), adapted from
the bctpy implementation: <a class="reference external" href="https://github.com/aestrivex/bctpy">https://github.com/aestrivex/bctpy</a></p>
<p>Transitivity is the ratio of triangles to triplets in the network and is
a classical version of the clustering coefficient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>A</strong> (<em>NxN np.ndarray</em>) – binary undirected connection matrix</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>T</strong> – transitivity scalar</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="comet-multiverse">
<h2>comet.multiverse<a class="headerlink" href="#comet-multiverse" title="Link to this heading"></a></h2>
<div class="toctree-wrapper compound">
</div>
<dl class="py class" id="module-comet.multiverse">
<dt class="sig sig-object py" id="comet.multiverse.Multiverse">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">comet.multiverse.</span></span><span class="sig-name descname"><span class="pre">Multiverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'multiverse'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/multiverse.html#Multiverse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.multiverse.Multiverse" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Multiverse class for creating, running, and visualizing the multiverse analysis.</p>
<p>This class provides functionality to create multiple analysis scripts based on different decision paths,
run them in parallel, and visualize the results as a network or specification curve.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="comet.multiverse.Multiverse.name">
<span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#comet.multiverse.Multiverse.name" title="Link to this definition"></a></dt>
<dd><p>Name of the multiverse analysis. Default is “multiverse”.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="comet.multiverse.Multiverse.create">
<span class="sig-name descname"><span class="pre">create</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">analysis_template</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">forking_paths</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invalid_paths</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/multiverse.html#Multiverse.create"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.multiverse.Multiverse.create" title="Link to this definition"></a></dt>
<dd><p>Create the individual universe scripts</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>analysis_template</strong> (<em>function</em>) – Function containing the analysis template</p></li>
<li><p><strong>forking_paths</strong> (<em>dict</em>) – Dictionary containing the forking paths</p></li>
<li><p><strong>invalid_paths</strong> (<em>list</em>) – List of invalid paths that should be excluded from the multiverse</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="comet.multiverse.Multiverse.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">universe_number</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parallel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/multiverse.html#Multiverse.run"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.multiverse.Multiverse.run" title="Link to this definition"></a></dt>
<dd><p>Run either an individual universe or the entire multiverse</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> (<em>string</em>) – Path of the multiverse directory</p></li>
<li><p><strong>universe_number</strong> (<em>int</em>) – Number of the universe to run. Default is None, which runs all universes</p></li>
<li><p><strong>parallel</strong> (<em>int</em>) – Number of universes to run in parallel</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="comet.multiverse.Multiverse.specification_curve">
<span class="sig-name descname"><span class="pre">specification_curve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'multiverse_summary.csv'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measure</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Set2'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ci</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">95</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chance_level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linewidth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(16,</span> <span class="pre">9)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">height_ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(2,</span> <span class="pre">1)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fontsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dotsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label_offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-0.05</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/multiverse.html#Multiverse.specification_curve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.multiverse.Multiverse.specification_curve" title="Link to this definition"></a></dt>
<dd><p>Create and save a specification curve plot from multiverse results</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fname</strong> (<em>string</em>) – Name of the .csv file containing the multiverse summary. Default is “multiverse_summary.csv”</p></li>
<li><p><strong>measure</strong> (<em>string</em>) – Name of the measure to plot. Default is None</p></li>
<li><p><strong>cmap</strong> (<em>string</em>) – Colormap to use for the nodes. Default is “Set2”</p></li>
<li><p><strong>ci</strong> (<em>int</em>) – Confidence interval to plot. Default is 95</p></li>
<li><p><strong>chance_level</strong> (<em>float</em>) – Chance level to plot. Default is None</p></li>
<li><p><strong>linewidth</strong> (<em>int</em>) – Width of the boxplots. Default is 2</p></li>
<li><p><strong>figsize</strong> (<em>tuple</em>) – Size of the figure. Default is (16,9)</p></li>
<li><p><strong>height_ratio</strong> (<em>tuple</em>) – Height ratio of the two subplots. Default is (2,1)</p></li>
<li><p><strong>fontsize</strong> (<em>int</em>) – Font size of the labels. Default is 10</p></li>
<li><p><strong>dotsize</strong> (<em>int</em>) – Size of the dots. Default is 50</p></li>
<li><p><strong>label_offset</strong> (<em>float</em>) – Offset of the labels. Needs to be adjusted manually, default is -0.05</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="comet.multiverse.Multiverse.summary">
<span class="sig-name descname"><span class="pre">summary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">universe</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">range(1,</span> <span class="pre">5)</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/multiverse.html#Multiverse.summary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.multiverse.Multiverse.summary" title="Link to this definition"></a></dt>
<dd><p>Print the multiverse summary to the terminal/notebook</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>universe</strong> (<em>int</em><em> or </em><em>range</em>) – The universe number(s) to display. Default is range(1,5)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="comet.multiverse.Multiverse.visualize">
<span class="sig-name descname"><span class="pre">visualize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">universe</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Set2'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(8,</span> <span class="pre">5)</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/multiverse.html#Multiverse.visualize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.multiverse.Multiverse.visualize" title="Link to this definition"></a></dt>
<dd><p>Visualize the multiverse as a network</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>universe</strong> (<em>int</em>) – The universe to highlight in the network. Default is None</p></li>
<li><p><strong>cmap</strong> (<em>str</em>) – Colormap to use for the nodes. Default is “Set2”</p></li>
<li><p><strong>node_size</strong> (<em>int</em>) – Size of the nodes. Default is 1500</p></li>
<li><p><strong>figsize</strong> (<em>tuple</em>) – Size of the figure. Default is (8,5)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="comet.multiverse.in_notebook">
<span class="sig-prename descclassname"><span class="pre">comet.multiverse.</span></span><span class="sig-name descname"><span class="pre">in_notebook</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/multiverse.html#in_notebook"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.multiverse.in_notebook" title="Link to this definition"></a></dt>
<dd><p>Helper function to check if the code is running in a Jupyter notebook</p>
</dd></dl>

</section>
<section id="comet-data">
<h2>comet.data<a class="headerlink" href="#comet-data" title="Link to this heading"></a></h2>
<div class="toctree-wrapper compound">
</div>
<dl class="py function" id="module-comet.data">
<dt class="sig sig-object py" id="comet.data.clean">
<span class="sig-prename descclassname"><span class="pre">comet.data.</span></span><span class="sig-name descname"><span class="pre">clean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_series</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">runs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detrend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">confounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">standardize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">standardize_confounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'butterworth'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">low_pass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">high_pass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t_r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ensure_finite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/data.html#clean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.data.clean" title="Link to this definition"></a></dt>
<dd><p>Wrapper function for nilearn.clean() for cleaning time series data</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time_series</strong> (<em>TxP np.ndarray</em>) – time series data</p></li>
<li><p><strong>runs</strong> (<em>np.ndarray</em><em>, </em><em>optional</em>) – Add a run level to the cleaning process. Each run will be cleaned independently.
Must be a 1D array of n_samples elements.</p></li>
<li><p><strong>detrend</strong> (<em>bool</em><em>, </em><em>optional</em>) – Detrend the data. Default is False.</p></li>
<li><p><strong>confounds</strong> (<em>np.ndarray</em><em>, </em><em>str</em><em>, </em><em>pathlib.Path</em><em>, </em><em>pandas.DataFrame</em><em>, or </em><em>list</em><em> of </em><em>confounds</em>) – Confounds to be regressed out from the data. Default is None.</p></li>
<li><p><strong>standardize</strong> (<em>bool</em><em>, </em><em>optional</em>) – Z-score the data. Default is False.</p></li>
<li><p><strong>standardize_confounds</strong> (<em>bool</em><em>, </em><em>optional</em>) – Z-score the confounds. Default is True.</p></li>
<li><p><strong>filter</strong> (<em>str {butterworth</em><em>, </em><em>cosine</em><em>, </em><em>False}</em>) – Filtering method. Default is ‘butterworth’.</p></li>
<li><p><strong>low_pass</strong> (<em>float</em><em>, </em><em>optional</em>) – Low cutoff frequency in Hertz. Default is None.</p></li>
<li><p><strong>high_pass</strong> (<em>float</em><em>, </em><em>optional</em>) – High cutoff frequency in Hertz. Default is None.</p></li>
<li><p><strong>t_r</strong> (<em>float</em><em>, </em><em>optional</em>) – Repetition time, in seconds (sampling period). Default is None</p></li>
<li><p><strong>ensure_finite</strong> (<em>bool</em><em>, </em><em>optional</em>) – Check if the data contains only finite numbers. Default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>data</strong> – cleaned time series data</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>TxP np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="comet.data.load_example">
<span class="sig-prename descclassname"><span class="pre">comet.data.</span></span><span class="sig-name descname"><span class="pre">load_example</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ftype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/data.html#load_example"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.data.load_example" title="Link to this definition"></a></dt>
<dd><p>Load simulation time series with two randomly changing connectivity states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ftype</strong> (<em>str</em><em>, </em><em>optional</em>) – File type to load. If specified as “pkl”, a .pkl file with additional
information is loaded. Otherwise, only time series data is returned.
Default is None.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>data</strong> – If <cite>ftype</cite> is not specified or is None, the function returns a
TxP np.ndarray containing the time series data</p>
<dl class="simple">
<dt>If <cite>ftype</cite> is “pkl”, the function returns a tuple containing:</dt><dd><ul class="simple">
<li><p>data[0] : TxP np.ndarray
Time series data.</p></li>
<li><p>data[1] : np.ndarray
Time in seconds.</p></li>
<li><p>data[2] : np.ndarray
Trial onsets in seconds.</p></li>
<li><p>data[3] : np.ndarray
Trial labels indicating two changing connectivity states.</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray or tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="comet.data.load_single_state">
<span class="sig-prename descclassname"><span class="pre">comet.data.</span></span><span class="sig-name descname"><span class="pre">load_single_state</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/data.html#load_single_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.data.load_single_state" title="Link to this definition"></a></dt>
<dd><p>Load simulated time series data with a single connectivity state</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data</strong> – Single state time series data</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>TxP np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="comet.data.load_timeseries">
<span class="sig-prename descclassname"><span class="pre">comet.data.</span></span><span class="sig-name descname"><span class="pre">load_timeseries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/data.html#load_timeseries"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.data.load_timeseries" title="Link to this definition"></a></dt>
<dd><p>Load time series data from a file.
Supported file formats are: .pkl, .txt, .npy, .mat, and .tsv</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>path</strong> (<em>string</em>) – path to the time series data file.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>data</strong> – time series data</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>TxP np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="comet.data.save_results">
<span class="sig-prename descclassname"><span class="pre">comet.data.</span></span><span class="sig-name descname"><span class="pre">save_results</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">universe</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/comet/data.html#save_results"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#comet.data.save_results" title="Link to this definition"></a></dt>
<dd><p>Save all kinds of results as .pkl file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ftype</strong> (<em>str</em><em>, </em><em>optional</em>) – File type to load. If specified as “pkl”, a .pkl file with additional
information is loaded. Otherwise, only time series data is returned.
Default is None.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>data</strong> – If <cite>ftype</cite> is not specified or is None, the function returns a
TxP np.ndarray containing the time series data</p>
<dl class="simple">
<dt>If <cite>ftype</cite> is “pkl”, the function returns a tuple containing:</dt><dd><ul class="simple">
<li><p>data[0] : TxP np.ndarray
Time series data.</p></li>
<li><p>data[1] : np.ndarray
Time in seconds.</p></li>
<li><p>data[2] : np.ndarray
Trial onsets in seconds.</p></li>
<li><p>data[3] : np.ndarray
Trial labels indicating two changing connectivity states.</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray or tuple</p>
</dd>
</dl>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="usage.html" class="btn btn-neutral float-left" title="Usage" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="contribute.html" class="btn btn-neutral float-right" title="Contributing" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Micha Burkhardt.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>